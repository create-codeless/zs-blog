INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (15, 'APP 中的 JS 加密逆向解析', 1, 2, 'https://www.lujianxin.com//media/blog/cover/prometheus.png', 1, '<p>APP 加载 JS 的逆向解析方法</p>\n<p><strong>抓取登录包</strong></p>\n<p>解决安全检测</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress5-1601444181.png" alt="APP 中的 JS 加密逆向解析1"/></p>\n<p>\xa0</p>\n<p>使用木木模拟器，安装好app刚准备愉快的抓个包。竟然检测到root，不能进入。那就先把这个给他hook掉。</p>\n<p>用jadx打开apk，全局搜索一下，提示的文字。</p>\n<p>\xa0</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1601444181.png" alt="APP 中的 JS 加密逆向解析2"/></p>\n<p>\xa0</p>\n<p>可以看到这里进行了几种检测，编写frida hook代码，直接把 initCheckSafe 方法置空</p>\n<p>\xa0</p>\n<p>解决完毕，我们再进入app</p>\n<p>\xa0</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444181.png" alt="APP 中的 JS 加密逆向解析3"/></p>\n<p>又提示要跟新，事是真的多。那就更新吧。点击更新后，加载了一些东西，然后进入了登录页面。（!!! 后面发现这里的坑）</p>\n<p>\xa0</p>\n<p><strong>抓包分析</strong></p>\n<p>\xa0</p>\n<p>配置好代理，直接抓包。<br/>\n可以看到请求的数据模式都是<br/>\naction=xxxx&amp;data=json</p>\n<p>\xa0</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1601444181-1.png" alt="APP 中的 JS 加密逆向解析4"/></p>\n<p>\xa0</p>\n<p>把这个json数据拿出来看看，多尝试几次发现密码不变这个password不变，其他的参数都可以写死。到这里，如果账号少的话，手动抓一次包后续使用就可以了。但是咱能满足于此吗，盘它！</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444182.png" alt="APP 中的 JS 加密逆向解析5" width="219.07072pt" height="453.6pt"/></p>\n<p>\xa0</p>\n<p><strong>寻找加密位置</strong></p>\n<p><strong>盲狙碰运气</strong></p>\n<p>这个参数看着像是，某种加密后base64的结果。先base64解码看看啥情况。将加密后的值urldecode之 \xa0 \xa0后再base64解码</p>\n<p><img title="APP 中的 JS 加密逆向解析6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444182.png" alt="APP 中的 JS 加密逆向解析6" width="443.29172pt" height="273.6pt"/></p>\n<p>\xa0</p>\n<p>一堆乱码看不懂。那我们使用南山大佬写的xposed的模块把常见加密hook一波，尝试快速定位。激活xposed plus模块，然后打开ddms，查看日志信息。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444182.jpeg" alt="APP 中的 JS 加密逆向解析7" width="432.9008pt" height="200.02496pt"/></p>\n<p><img title="APP 中的 JS 加密逆向解析8" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress6-1601444182.jpeg" alt="APP 中的 JS 加密逆向解析8" width="447.6163pt" height="203.80496pt"/></p>\n<p>\xa0</p>\n<p>可以看到常见的加密类都被hook到了，但是在保存的日志中尝试搜索输入的密码，抓包的加密结果等， 都一无所获。</p>\n<p>\xa0</p>\n<p><strong>搜索反编译代码</strong></p>\n<p>\xa0</p>\n<p>看来好事多磨，快的不行那我们去分析代码吧。</p>\n<p>尝试搜索 登录链接 登录参数字段值等，都寻找不到有用的信息，事情好像陷入了僵局。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析9" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444183.png" alt="APP 中的 JS 加密逆向解析9" width="441.38245pt" height="337.1775pt"/></p>\n<p>\xa0</p>\n<p><strong>巧计寻出路</strong></p>\n<p>\xa0</p>\n<p>静静思考一会，回想到登录接口参数data后面的值是一个json类型，也就是字典类型。那能不能hook java中这个类，看看有没有password赋值的操作</p>\n<p>百度一波，得到如下hook代码</p>\n<p>\xa0</p>\n<p>把这代码灵活运用一下，我们再登录一次看看结果。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析10" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444183.png" alt="APP 中的 JS 加密逆向解析10" width="444.48254pt" height="236.85748pt"/></p>\n<p>\xa0</p>\n<p>果然发现了赋值操作，那就过滤一下无用的信息，再把这个操作的调用栈打印出来，顺藤摸瓜，那不就 \xa0能找到加密位置了嘛。感觉看到了希望。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析11" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444183-1.png" alt="APP 中的 JS 加密逆向解析12" width="406.83118pt" height="291.45pt"/></p>\n<p>\xa0</p>\n<p>还好调用栈不是很多，去掉 java开头的和proxy，剩下的我们从上面开始一个个看一下，有没有加密的地方。</p>\n<p>一直找到最下面这个方法,参数可以看到是从 exec 这个函数的参数传来的。那么hook这个exec的入参看一下。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析13" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析13" width="445.2466pt" height="290.7pt"/></p>\n<p>\xa0</p>\n<p>hook 结果：</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析14" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress7-1601444184.png" alt="APP 中的 JS 加密逆向解析14" width="444.75pt" height="54.75pt"/></p>\n<p>\xa0</p>\n<p>这下蒙蔽了，都追到根了，咋还是加密过的值呢。</p>\n<p>\xa0</p>\n<p><strong>再肯硬骨头</strong></p>\n<p><strong>发现线索一</strong></p>\n<p>有困难但是也不能放弃。再自己端详一下exec的代码，发现它头部有个@JavascriptInterface好像装饰 器一样的东西，和别的函数都不一样。<br/>\n不懂咱就去搜索一下，然后发现这个是可以让 js 和 java 互相调用的一个东西。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析15" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析15" width="443.7912pt" height="76.259926pt"/></p>\n<p>\xa0</p>\n<p>那就知道方向了，加密是在js中进行的，然后js中调用java里的exec方法，将值传了进来。</p>\n<p>将apk反编译，先去找找那些js中，有cbPassInfo setOfflineCache这些信息。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析16" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析16" width="444.78873pt" height="172.51495pt"/></p>\n<p>\xa0</p>\n<p>哟呵，搜到了这两个里面有。把他俩拖出来瞅一瞅。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析17" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析17" width="443.59882pt" height="127.170006pt"/></p>\n<p>\xa0</p>\n<p>在 login.js 里面只有这两处。先验证一下这里是不是传加密值的地方。</p>\n<p>我把这里的 cbPassInfo 改成别的字符串，然后重新打包签名apk，安装，再抓取一次登录包，如果出现的是我修改的字符，那说明这就是调用的位置。</p>\n<p>信心满满，又抓了一次包。结果啪啪打脸。还是 cbPassInfo 。</p>\n<p>\xa0</p>\n<p><strong>发现线索二</strong></p>\n<p>突然想到，重新安装打开后，有个提示框，更新资源，难道它又重新下载了这个文件，把我修改的重置 \xa0了。</p>\n<p>卸载，重装后，抓包查看下它更新的资源，发现果然是这样。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析18" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184.png" alt="APP 中的 JS 加密逆向解析18" width="447.34598pt" height="175.77pt"/></p>\n<p>\xa0</p>\n<p>既然修改apk不行，js又是静态文件，那直接在模拟器中搜索login.js<br/>\n结果有3，4个，把文件重命名，app打开没了登录界面，那就是它了。</p>\n<p>\xa0</p>\n<p><strong>模拟加密</strong></p>\n<p><strong>分析js</strong></p>\n<p>先分析一下js，密码就是通过蓝框两个方法加密的。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析19" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184-1.jpeg" alt="APP 中的 JS 加密逆向解析19" width="445.2799pt" height="176.46pt"/></p>\n<p>\xa0</p>\n<p>先搜索一下 D 和 Base64，Base64没有获得有效的信息。发现D应该和 sha1 有关系</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析20" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444185.jpeg" alt="APP 中的 JS 加密逆向解析20" width="443.6568pt" height="133.91992pt"/></p>\n<p>\xa0</p>\n<p>这里js不好调试，我们利用js调用java的流程，把我们想要的值传给java层，然后去hook接收的函数。这 \xa0 \xa0 \xa0里把我把用到的函数，各种结果都打印了一下。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析21" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1601444185.png" alt="APP 中的 JS 加密逆向解析21" width="444.0pt" height="134.25pt"/></p>\n<p><img title="APP 中的 JS 加密逆向解析22" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1601444185.jpeg" alt="APP 中的 JS 加密逆向解析22" width="449.93283pt" height="96.36pt"/></p>\n<p>\xa0</p>\n<p>这个D刚才看是和sha1相关的，用标准的sha1对比一下。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析23" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444185.png" alt="APP 中的 JS 加密逆向解析23" width="443.68427pt" height="162.36pt"/></p>\n<p>发现和上面结果相同。那就只剩base64这个函数了。看打印出来的代码，发现这不是一个标准的base64，运行报错缺少 c 变量。</p>\n<p>搜素函数内的代码，在common.js中发现了</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析24" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444185-1.png" alt="APP 中的 JS 加密逆向解析24" width="443.46616pt" height="72.54pt"/></p>\n<p>\xa0</p>\n<p>现在逻辑清楚了，把c的值拿过来，用js来实现加密。可以看到结果和抓包一致，收工。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析25" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444185.jpeg" alt="APP 中的 JS 加密逆向解析25" width="444.00867pt" height="179.7pt"/></p>\n<p>\xa0</p>\n<p><strong>总结</strong></p>\n<p>之前遇到的app都是在java代码中加密，或者 so库里面。在js中的这是第一次遇到。</p>\n<p>幸运的是js没有做处理，如果把web端的反扒应用在这，手机端又不好对js进行调试，那真是够秃头的了，可怕。</p>\n<p>这篇来自小伙伴 ID: 浮生 的投稿。</p>\n<p>安利下偶的爬虫逆向进阶课，包含 安卓逆向抓取/安卓群控/JS逆向抓取/爬虫框架设计与工程经验，国庆时正好学习下，目前熟悉安卓逆向抓取技术拿个20K+ 的 offer 还是容易。</p>\n<p><strong>具体点击下面连接</strong></p>\n<p><a href="https://www.yuanrenxue.com/crawler/crawler-course.html" target="_blank" rel="noopener">我出了一套爬虫高阶学习课</a></p>\n<p>\xa0</p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'APP 加载 JS 的逆向解析方法抓取登录包解决安全检测\xa0使用木木模拟器，安装好app刚准备愉快的抓个包。竟然检测到root，不...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (16, '安卓逆向之Luac解密反编译', 1, 2, 'https://www.lujianxin.com//media/blog/cover/linux-cover.jpg', 1, '<p>本文阐述针对Cocos2dx-lua提供的轻量级加密方案的反编译。</p>\n<p>本文demo对象：</p>\n<p><img title="安卓逆向之Luac解密反编译1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress1-1600222829.png" alt="安卓逆向之Luac解密反编译1"/></p>\n<p>lua文件大概分3种。lua是明文代码，直接用ide能打开，luac是lua编译后的字节码，文件头特征为0x1B 0x4C 0x75 0x61 0x51。</p>\n<p>lua虚拟机直接解析lua和luac脚本文件，luaJIT是另一个lua的实现版本，采用即时解析运行机制，luaJIT更高效，文件头特征为0x1B 0x4C 0x4A。</p>\n<p><strong>加密流程</strong></p>\n<p>一篇文章搞定Cocos2dx-lua正向开发打包流程：</p>\n<p>CSDN文章【Cocos2dx-lua 3.11.1】打包lua项目为安卓apk</p>\n<p>https://blog.csdn.net/lannan91/article/details/67637373/</p>\n<p>加密指令：cocos luacompile -s 未加密源码目录 -d 加密后源码目录 -e -k 加密key -b 加密sign –disable-compile<br/>\n“</p>\n<p><strong>解密逻辑</strong></p>\n<p>lua官方加解密实现方式很容易就能查找资料得到，根据得到key和sign就可以利用xxtea算法来对脚本进行解密，只需要三个条件，文件路径&amp;加密sign&amp;加密key就能解密。<br/>\n加密和解密算法在这：<br/>\nhttps://github.com/cocos2d/cocos2d-x-3rd-party-libs-bin/tree/v3/xxtea</p>\n<p><strong>实现过程</strong></p>\n<p>加密sign的找寻方法sign在.luac文件头中<br/>\n随机打开一个项目内的.luac文件，找第一个字符串。</p>\n<p><img title="安卓逆向之Luac解密反编译2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress5-1600222829.jpeg" alt="安卓逆向之Luac解密反编译2"/></p>\n<p>\xa0</p>\n<p><strong>加密key的找寻方法</strong></p>\n<p>key在打包后的cocos的lib库的libcocos2dlua.so中<br/>\n1.第一种方法是libcocos2dlua.so使用IDA pro打开，全局查找加密sign。点击进入查找结果，在该结果的上方3行能够发现加密key。<br/>\n2.第二种方法，由于写作的电脑已经升级到10.15.5 (19F101)，IDA pro运行有问题。所以用osx自带的strings工具查找。<br/>\n2-1.终端运行\xa0strings -a libcocos2dlua.so<br/>\n2-2.ctrl+f 查找sign，观察sign上方的字符串，即为key。</p>\n<p><img title="安卓逆向之Luac解密反编译3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1600222829.png" alt="安卓逆向之Luac解密反编译3"/></p>\n<p><strong>解密实现</strong></p>\n<p>OSX实现脚本：<br/>\nhttps://github.com/dengxiaochun/luac_decodeToolwin实现工具：<br/>\nhttps://www.jb51.net/softs/575428.htmlOSX演示：<br/>\n将解密脚本放在项目assets目录下</p>\n<p><img title="安卓逆向之Luac解密反编译4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1600222830.png" alt="安卓逆向之Luac解密反编译4"/></p>\n<p>修改decode.sh的SIGN&amp;KEY变量，并保存。</p>\n<p><img title="安卓逆向之Luac解密反编译5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress1-1600222831.png" alt="安卓逆向之Luac解密反编译5"/></p>\n<p>终端执行：sh ./decode.sh src</p>\n<p><img title="安卓逆向之Luac解密反编译6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1600222831.png" alt="安卓逆向之Luac解密反编译6"/></p>\n<p>执行结果：</p>\n<p><img title="安卓逆向之Luac解密反编译7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1600222832.png" alt="安卓逆向之Luac解密反编译7"/></p>\n<p>\xa0</p>\n<p>执行后脚本将自动备份luac源代码（src_backup）</p>\n<p><img title="安卓逆向之Luac解密反编译8" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1600222833.png" alt="安卓逆向之Luac解密反编译8"/></p>\n<p>解密后的.lua文件在src目录中，ide打开，源代码反编译成功，可以进一步研究程序的客户端源码实现。</p>\n<p><img title="安卓逆向之Luac解密反编译9" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress10-1600222834.png" alt="安卓逆向之Luac解密反编译9"/></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本文阐述针对Cocos2dx-lua提供的轻量级加密方案的反编译。本文demo对象：lua文件大概分3种。lua是明文代码，直接用ide能打开，lu...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (17, '巧破某报价大全APP加密参数-iOS逆向抓取', 1, 2, 'https://www.lujianxin.com//media/blog/cover/CPU-cover.png', 1, '<p>iOS作为一种闭源系统，没有Android那么多的packers和so库，iOS官方封装了自己统一的Crypto库，所以我们HOOK起来也很方便。我以某报价大全 iOS v10.5.5版为例，记录一下巧破加密参数的过程和一些知识点。</p>\n<p>此次逆向教程使用到的工具如下：</p>\n<p>一部越狱iPhone或iPad</p>\n<p>抓包工具：Charles</p>\n<p>Hook 框架：frida v12.8.11</p>\n<p>通过Charles抓取目标APP列表页请求的数据，我们发现含有32位的“sign”参数，且向下滑动加载更多时“sign”参数都会变化。两次抓包请求参数对比如下图：</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress3-1591693046.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数1"/></p>\n<p>通过对比抓包数据，我们猜测可能使用了MD5加密算法，接下来我们就用frida-trace监控iOS系统封装的CC_MD5加密函数，看能不能巧破该APP的“sign”参数。</p>\n<p>首先通过 frida-ps -Ua （请自行安装frida）查看目标APP的进程id为4934：<br/>\n<img title="iOS逆向抓取-巧破某报价大全APP加密参数2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591693046.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数2"/></p>\n<p>\xa0</p>\n<p>再通过frida-trace跟踪“CC_MD5”函数，命令如下：</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress9-1591693046.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数3"/></p>\n<p>\xa0</p>\n<p>frida-trace参数说明如下：</p>\n<p>-U\xa0\xa0 \xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 使用USB数据线连接设备</p>\n<p>-i\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0追踪函数</p>\n<p>“CC_MD5” \xa0 \xa0要追踪的函数名</p>\n<p>4934 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0目标APP进程id</p>\n<p>接着在终端界面按 Ctrl+C 停止运行。然后在__handlers__/ASEProcessing文件夹中找到CC_MD5.js文件，将代码修改为如下并保存：</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress6-1591693046.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数4"/></p>\n<p>\xa0</p>\n<p>以上代码会在追踪到CC_MD5函数步入时打印待加密的参数值，步出时打印加密后的md5返回值。<br/>\n接着我们继续使用之前的命令运行frida-trace，然后在目标APP列表页继续滑动即可看到frida-trace追踪到的参数和返回值。然后我们用Charles抓包看到的sign值到frida-trace窗口中搜索即可找到对应参数，如下图：</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress0-1591693047.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数5"/></p>\n<p>对比请求的url和加密参数：<br/>\n-请求的url：api.ashx?cateid=3&amp;cityid=&amp;method=news.list&amp;pageindex=3&amp;pagesize=25&amp;productid=7&amp;serialid=&amp;sign=fbe1c8222424f38371f0b59592a6293b-加密的参数：?cateid=3&amp;cityid=&amp;method=news.list&amp;pageindex=3&amp;pagesize=25&amp;productid=7&amp;serialid=2CB3147B-D93C-964B-47AE-EEE448C84E3C</p>\n<p>请求url中标注部分与加密参数标注部分完全一致，我们可以确定盐值为：2CB3147B-D93C-964B-47AE-EEE448C84E3C。至此“sign”参数md5加密算法不攻自破了。</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591693047.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数6"/></p>\n<p>\xa0</p>\n<p>本文重点在通过Charles抓包看到“sign”参数为32位字符串，猜测是md5加密，从而使用frida-trace监控目标APP是否使用了iOS系统封装的CC_MD5加密函数。之后一击即中巧破了“sign”参数加密算法。</p>\n<p>对于我们爬虫工作者在抓取数据时遇到加密“sign”参数，首先可以猜测其大致的算法，之后用frida-trace去监测系统默认的加密函数，比如iOS系统的：CC_MD5，CC_SHA1，CCHmac等，有可能会有意想不到的收获。如果此方法行不通，我们可以再去想办法逆向分析。</p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'iOS作为一种闭源系统，没有Android那么多的packers和so库，iOS官方封装了自己统一的Crypto库，所以我们HOOK起来也很方便。我以某报...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (18, 'APP爬虫-某APP iOS版逆向过程', 1, 2, 'https://www.lujianxin.com//media/blog/cover/prometheus.png', 1, '<p>本篇来自周小鱼同学的投稿，跟着猿人学王平大佬学了一段时间安卓APP逆向，刚刚入门。由于我使用Mac和iOS更频繁，所以我以某汽车 iOS 版为例，记录一下逆向过程和一些知识点。</p>\n<p><strong>此次逆向教程使用到的工具如下：</strong></p>\n<p>一部越狱iPhone或iPad<br/>\n抓包工具：Charles<br/>\n反编译分析工具：IDA64_v7.0<br/>\nHook 框架：objection v1.9.1<br/>\nhttps://github.com/sensepost/objection<br/>\n调试工具：LLDB，Debugserver</p>\n<p>抓包发现含有32位数的“_r”参数(可能为MD5加密)以及34位数的sign参数，且每次请求都会变化。经过反复抓包对比测试，发现无论修改任何参数再提交服务器都会返回url签名错误，并且发现sign参数最后2位数不变，猜测是32位数MD5密文加字符串“01”组成。接下来的重点就是分析“sign”和“_r”是怎么生成的。</p>\n<p>两次抓包参数文本对比效果图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress6-1591691472.png" alt="APP爬虫-某APP iOS版逆向过程1"/></p>\n<p>使用 frida-iOS-dump 一键砸壳后，将砸壳后的二进制文件拖入到IDA中进行分析。由于“sign”关键字可能存在太多干扰不利于分析，所以我们从一个可能干扰比较少的关键字“ttDna” 开始分析。</p>\n<p>在IDA strings 窗口搜索ttDna，有且只有一个结果完全吻合，如下图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress0-1591691472.png" alt="APP爬虫-某APP iOS版逆向过程2"/></p>\n<p>通过这个关键字，我们进入到了函数：-[CBDBaseApi extraParams]，果断使用 objection（如何使用请自行查阅资料） 对此函数进行hook，查看其参数、返回值和调用堆栈，截图如下：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress8-1591691473.png" alt="APP爬虫-某APP iOS版逆向过程3"/></p>\n<p>返回值确实包含了我们抓包中看到的信息，但是不完整，需要继续追踪调用函数。</p>\n<p>通过第一个堆栈地址 0xc4ed40 + IDA64头部偏移量 0x100000000 =\xa00x100c4ed40 找到IDA64中相应地址调用的地方，发现在函数：-[MCCBaseApi buildFullUrl:] 内部。我们继续使用 objection 对此函数进行 hook，发现返回值与我们抓包看到的完全吻合：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress4-1591691473.png" alt="APP爬虫-某APP iOS版逆向过程4"/></p>\n<p>从上面返回值的截图可以看出完整的url是由此函数拼装而成，接下来我们在IDA64中按F5键查看该函数的伪代码，逆向由下往上分析：<br/>\nreturn=v21=v20=v14=v13，<br/>\n发现返回值是<br/>\n+[MCCURLManager buildUrlString:withParams:sign:]<br/>\n生成的：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591691473.png" alt="APP爬虫-某APP iOS版逆向过程5"/></p>\n<p>继续追踪<br/>\n-[MCCURLManager buildUrlString:withParams:sign:] ，</p>\n<p>发现来自于<br/>\n-[MCCURLManager buildUrlString:withParams:sign:useBasicParam:usePublicParam:]。<br/>\n在此函数中，我们发现了“_r”参数。</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress9-1591691473.png" alt="APP爬虫-某APP iOS版逆向过程6"/></p>\n<p>经过分析“_r”参数是随机生成的UUID经过MD5加密得到。</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress0-1591691474.png" alt="APP爬虫-某APP iOS版逆向过程7"/></p>\n<p>继续一路追踪sign参数，发现到了一个跟sign有关的函数：+[MCCSignURLManager signUrl1:withKey:]，果断使用 objection hook该函数，参数和返回值仅仅只多了一串sign参数，由此可以判断sign在此函数内生成，并且发现key值是：<br/>\nSW+SaqSibZdCmqNyh4WYlW+l，<br/>\n截图如下：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程8" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress9-1591691474.png" alt="APP爬虫-某APP iOS版逆向过程8"/></p>\n<p>继续分析该函数的伪代码，我们看到一个自定义的函数 SignUrl1，如下图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程9" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress3-1591691474.png" alt="APP爬虫-某APP iOS版逆向过程9"/></p>\n<p>双击进入SignUrl1，我们又看到另一个自义定函数 SignUrl0，如下图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程10" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress10-1591691474.png" alt="APP爬虫-某APP iOS版逆向过程10"/></p>\n<p>双击进入SignUrl0，我们看到熟悉的MD5加密算法，如下图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程11" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress8-1591691475.png" alt="APP爬虫-某APP iOS版逆向过程11"/></p>\n<p>逆向分析到此，我们可以大胆猜测，SignUrl1是在组装加密参数，之后将参数传递给 SignUrl0 进行MD5加密之后再将密文返回给SignUrl1。</p>\n<p>现在我们只需要查看SignUrl0函数的具体参数就可以知道如何加密了。接下来我们使用LLDB+debugserver（具体如何使用请自行查阅资料）在图下位置下断点并查看传入的具体参数：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程12" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress10-1591691475.png" alt="APP爬虫-某APP iOS版逆向过程12"/></p>\n<p>参数1为不包含sign参数部分的请求内容，部分截图如下：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程13" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress5-1591691475.png" alt="APP爬虫-某APP iOS版逆向过程13"/></p>\n<p>参数2为key值经过base64decode等步骤转换而来的固定字符串：<br/>\n5oBjPRiG2ZSbwqDAoQ，<br/>\n也就是MD5加密的盐。这里我们无需深究key是如何转换的，只需拿到key的固定字符串即可：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程14" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress6-1591691475.png" alt="APP爬虫-某APP iOS版逆向过程14"/></p>\n<p>所以sign参数算法就是由函数SignUrl0的入参1+入参2经MD5加密后与“01”拼接得到。接下来我们验证一下我们猜测的算法与抓包是否一致：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程15" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591691476.png" alt="APP爬虫-某APP iOS版逆向过程15"/></p>\n<p><img title="APP爬虫-某APP iOS版逆向过程16" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress3-1591691476.png" alt="APP爬虫-某APP iOS版逆向过程16"/></p>\n<p>由上面2张图可以看出sign参数算法完全正确，至此sign参数和“_r”参数全部告破。接下来就可以使用Python实现算法然后自由爬取文章了。</p>\n<p>本篇文章的案例用到了Charles抓包，frida-iOS-dump砸壳，IDA64反编译，objection HOOK框架，以及LLDB+debugserver调试等工具。每一个工具的使用都需要花大量时间研究，本文并未对以上工具的使用进行详细说明，感兴趣的同学可以自行查阅相关资料。</p>\n<p>案例中的APP也算是大厂开发的，而我们对其二进制文件的加密函数分析并不是太难，没有对关键字加密，没有复杂的算法，也没有对函数名进行混淆，直接使用IDA64进行静态分析，以及使用objection hook查看参数和返回值就追踪到了加密的函数。</p>\n<p>所以做爬虫工作碰到APP逆向这个事情，首先不要害怕，其实市场上大多数APP的加密参数都可以通过我们这种方式搞定。当然很难的也有很多，比如关键字加密，函数名混淆，反调试检测，多线程循环发包，网络发包封装第三方库等等，面对这些只要有信心有耐心，多学习实操总结，慢慢积累经验，会有所成的，大家共勉！</p>\n<p><strong>PS：广而告之：</strong><br/>\n把猿人学·爬虫高阶课又更新了，加入了安卓群控，详情点击<a href="https://www.yuanrenxue.com/crawler/advance-course.html">https://www.yuanrenxue.com/crawler/advance-course.html</a></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本篇来自周小鱼同学的投稿，跟着猿人学王平大佬学了一段时间安卓APP逆向，刚刚入门。由于我使用Mac和iOS更频繁，所以我以某汽车 iOS...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (19, '分析app的登陆协议', 1, 2, 'https://www.lujianxin.com//media/blog/cover/prometheus.png', 1, '<p>这是一篇逆向分析APP登陆流程的文章。</p>\n<p>（1） 抓包前将手机和电脑连接到同一WIFI，在手机设置好代理，装好证书，就可以开始抓包了。之前我遇到抓不到包的情况，换了几个代理工具也不行，最后是开着热点抓到包（一台开热点，另一台和电脑连接热点），或者换成手机抓包工具HttpCanary等也可以抓包。</p>\n<p>（2） 抓包环境配置好后，在登陆界面随便填一个账号密码：</p>\n<p><img title="分析app的登陆协议1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585810.png" alt="分析app的登陆协议1" width="264.0pt" height="159.65pt"/></p>\n<p>（3） 点击登录，查看Fiddler中的数据包数据包中的参数：city=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;citycode=010&amp;device=63ac32df-d1c2-3008-828e-ef9f1bb3a96d&amp;device_model=google%20Pixel%202&amp;device_name=google%20Pixel%202&amp;device_os=Android%205.1.1&amp;device_product=google&amp;device_size=1080*1920&amp;device_type=1&amp;district=%E4%B8%9C%E5%9F%8E%E5%8C%BA&amp;fake_id=37979341&amp;interface_code=620&amp;latitude=39.91640353732639&amp;longitude=116.41024359809028&amp;mobile=13426355456&amp;password=EBEDF39355506FF1F42AAD7A20E1DB83&amp;province=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;province_code=1582770774000&amp;version=6.2.0&amp;securitykey=41de91b2c71d0af71c7a71887e14b57d</p>\n<p>一般需要抓两次包来对比数据包参数的变化，观察哪些参数是固定或者容易得到的，哪些是不能直观看出需要进一步分析：</p>\n<p><img title="分析app的登陆协议2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress5-1590585810.png" alt="分析app的登陆协议2" width="415.25pt" height="120.35pt"/></p>\n<p>对比两个数据包可以看到，手机号没有加密，密码做了加密，还有一个参数securitykey也是加密的。这次逆向的重点也就是分析这两个参数的生成逻辑。</p>\n<p>（1） 直接把apk用jadx反编译，发现做了加固，是legu的壳，相关逻辑代码没法直接看到：</p>\n<p><img class="rich_pages" title="分析app的登陆协议3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress10-1590585811.png" alt="分析app的登陆协议3"/></p>\n<p>（2） 这里我使用了一个基于frida编写的脱壳工具：https://github.com/hluwa/FRIDA-DEXDump\xa0原理是在内存中暴力搜索，根据dex文件的结构特征将其dump下来，启动frida-server，启动app，运行脚本就可以了。如果使用过程中报错，可以试试重启手机，或者杀死app进程并重启app。</p>\n<p>（1）之前抓到的包是分析的入口点，在jadx中反编译dump下来的dex，点击菜单栏的小魔法棒搜索securitykey这个参数：</p>\n<p><img title="分析app的登陆协议4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585811.png" alt="分析app的登陆协议4" width="415.3pt" height="41.85pt"/></p>\n<p>结果如下;第四个GLOBAL_PARAMS_KEY = “securitykey”比较显眼，双击打开看看，也可以把右边所有结果挨个点开分析：</p>\n<p><img class="rich_pages" title="分析app的登陆协议5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585811.png" alt="分析app的登陆协议5"/></p>\n<p>\xa0</p>\n<p>观察代码，securitykey参数应该是在其他位置被引用，右键GLOBAL_PARAMS_KEY，选择查找用例，看看哪些地方用了这个参数：</p>\n<p><img title="分析app的登陆协议6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress8-1590585811.png" alt="分析app的登陆协议6" width="415.25pt" height="161.05pt"/></p>\n<p>根据经验推测，第二个stringBuffer.append一般是数据包参数构造的位置，双击打开它：</p>\n<p><img class="rich_pages" title="分析app的登陆协议7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress8-1590585812.png" alt="分析app的登陆协议7"/></p>\n<p>GLOBAL_PARAMS_KEY的值就是securitykey参数，接着拼接了一个“=”和一个finalSecStr的变量</p>\n<p><img title="分析app的登陆协议8" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585812.png" alt="分析app的登陆协议8" width="415.2pt" height="110.8pt"/></p>\n<p>双击这个finalSecStr变量，可以看到finalSecStr在代码中的处理逻辑，可以看到是经过getMD5Str这个方法处理得到的，看函数名感觉是计算MD5：</p>\n<p><img title="分析app的登陆协议9" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1590585812.png" alt="分析app的登陆协议9" width="415.2pt" height="181.6pt"/></p>\n<p>\xa0</p>\n<p>继续看getMD5Str的参数secStr，发现是由this.paramMap处理得到：</p>\n<p><img title="分析app的登陆协议10" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585812.png" alt="分析app的登陆协议10" width="415.15pt" height="138.1pt"/></p>\n<p>再往上分析，发现this.paramMap中值就是数据包那些参数：</p>\n<p><img title="分析app的登陆协议11" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1590585813.png" alt="分析app的登陆协议11" width="415.05pt" height="199.45pt"/></p>\n<p>自此，securitykey这个参数的计算逻辑差不多出来了，把this.paramMap中的参数挨个拼接“|”变成secStr，再传给getMD5Str，返回的值就是数据包中securitykey的值。<br/>\n按住Ctrl键，单击getMD5Str这个方法，可以看到就是MD5的计算：</p>\n<p><img title="分析app的登陆协议12" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress2-1590585813.png" alt="分析app的登陆协议12" width="415.2pt" height="239.15pt"/></p>\n<p>点击菜单栏中的向左小箭头返回上一层代码：</p>\n<p><img title="分析app的登陆协议13" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress8-1590585813.png" alt="分析app的登陆协议13" width="372.0pt" height="36.6pt"/></p>\n<p>我们可以通过hook getMD5Str方法，将其参数和返回值打印出来，验证我们的分析。这里涉及到一个问题，这个app加了壳，直接去hook会出现“ClassNotFoundError“的错误，这是因为getMD5Str这个方法不是一开始就在内存中的，它是被壳加载起来的。所以hook方法要有所改变。</p>\n<p>原理：所有的类都是通过ClassLoader的loadClass方法加载的，于是可以等我们要hook的这个方法所在的类被加载后再去hook，这样就可以百发百中了，多个DEX的情况下也可以使用这个方法该方法出处：https://bbs.pediy.com/thread-225190.htm</p>\n<p><img title="分析app的登陆协议14" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585813.png" alt="分析app的登陆协议14" width="465.05pt" height="294.5pt"/></p>\n<p>Hook getMD5Str方法后打印参数和返回值，编译安装xposed插件，重启手机，结果发现什么也没hook到，确认类名和方法名，参数都没问题。经过长时间的分析也没结论，最后是用ddms发现了问题：jadx反编译得到的类名，方法名不正确，与真实命名不一样。<br/>\n%1. ddms的使用ddms是一个AndroidSDK自带的方法追踪工具（一般位于SDK的tools目录下），用于记录app执行过的方法。这里我们需要记录的是点击登陆按钮后app执行的方法。打开ddms后，先选中app对应的进程，然后选择菜单栏中的“开始追踪”</p>\n<p><img class="rich_pages" title="分析app的登陆协议15" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585814.png" alt="分析app的登陆协议15"/></p>\n<p>\xa0</p>\n<p>选择第二个，记录所有方法</p>\n<p><img title="分析app的登陆协议16" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1590585814.png" alt="分析app的登陆协议16" width="381.0pt" height="207.6pt"/></p>\n<p>接着以最快的手速点击登录按钮（因为ddms会记录系统中在运行的很多进程的方法），等到弹出“该账号不存在”（因为我们随便输入的），立即点击ddms的“停止追踪”按键（跟“开始追踪”是同一个，不过现在变灰了），就能得到从点击登陆按钮后到账号校验完期间app执行的所有方法：</p>\n<p><img title="分析app的登陆协议17" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585814.png" alt="分析app的登陆协议17" width="414.95pt" height="66.55pt"/><br/>\n接着会弹出一个trace文件，就是记录下来的方法：<br/>\n<img title="分析app的登陆协议18" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress2-1590585814.png" alt="分析app的登陆协议18" width="414.9pt" height="148.2pt"/></p>\n<p>在最下面find搜索栏中输入app的包名，按回车键挨个观察记录下来的方法，在其中找到了getMD5Str方法的正确类路径，而之前在jadx中反编译得到的是：com.XXXXXX.common.utils.encrtption.MD5Helper.getMD5Str所以用jadx中的类路径肯定是hook不到getMD5Str方法了。</p>\n<p><img class="rich_pages" title="分析app的登陆协议19" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585815.png" alt="分析app的登陆协议19"/></p>\n<p>\xa0</p>\n<p>把类路径改成ddms记录的正确路径，重新编译hook插件，重启手机，运行app，输入账号密码，点击登录，在ddms的日志中可以发现，这次顺利的打印出了getMD5Str方法的参数和返回值：</p>\n<p><img title="分析app的登陆协议20" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress1-1590585815.png" alt="分析app的登陆协议20" width="509.05pt" height="157.5pt"/></p>\n<p>对比数据包参数：</p>\n<p><img title="分析app的登陆协议21" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585815-1.png" alt="分析app的登陆协议21" width="414.9pt" height="118.95pt"/></p>\n<p>将getMD5Str方法的参数与数据包中参数对比，发现是一致的，返回值就是参数的MD5值，验证了我们之前的分析是对的：</p>\n<p><img title="分析app的登陆协议22" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585815.png" alt="分析app的登陆协议22" width="370.8pt" height="181.85pt"/></p>\n<p>%1. password参数的分析分析完了securitykey这个参数，现在就分析password这个参数，可以发现，并没有在大量参数构造的地方发现password：</p>\n<p><img title="分析app的登陆协议23" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585816.png" alt="分析app的登陆协议23" width="415.05pt" height="199.45pt"/></p>\n<p>在jadx中搜索也没有发现：</p>\n<p><img class="rich_pages" title="分析app的登陆协议24" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress1-1590585816.png" alt="分析app的登陆协议24"/></p>\n<p>\xa0</p>\n<p>观察上面的参数，他们都是带着双引号的，尝试给password加上双引号搜索，终于看到了：</p>\n<p><img title="分析app的登陆协议25" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress10-1590585816.png" alt="分析app的登陆协议25" width="444.05pt" height="91.45pt"/></p>\n<p>第二个看着像是AES加密有关的，双击进去看看，果然是：</p>\n<p><img title="分析app的登陆协议26" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585816.png" alt="分析app的登陆协议26" width="510.5pt" height="79.65pt"/></p>\n<p>按住Ctrl，点开AesEncryptionHelper看看，是”AES/CBC/PKCS5Padding”的加密方法：</p>\n<p><img title="分析app的登陆协议27" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress9-1590585816.png" alt="分析app的登陆协议27" width="415.0pt" height="62.4pt"/></p>\n<p>验证一下：</p>\n<p><img title="分析app的登陆协议28" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585817.png" alt="分析app的登陆协议28" width="490.75pt" height="204.6pt"/></p>\n<p>跟数据包中的password的值是一样的：</p>\n<p><img title="分析app的登陆协议29" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585817.png" alt="分析app的登陆协议29" width="415.2pt" height="53.2pt"/></p>\n<p>自此，两个加密参数的分析就完成了。</p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '这是一篇逆向分析APP登陆流程的文章。1. 抓包（1） 抓包前将手机和电脑连接到同一WIFI，在手机设置好代理，装好证书，就可以开始...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (20, '正式把猿人学爬虫高阶课放在网课平台了', 1, 2, 'https://www.lujianxin.com//media/blog/cover/prometheus.png', 1, '<p><img class="rich_pages" title="正式把爬虫高阶课放在网课平台了" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1589809617.jpeg" alt="正式把爬虫高阶课放在网课平台了"/><br/>\n我跟 virjar 出了一套爬虫课（猿人学·爬虫高阶培训课），包含：安卓逆向抓取、JS 高阶逆向抓取、安卓群控抓取、容器定制化等。</p>\n<p>实际上我去年就在做这个爬虫课了，一直没有放到网课平台上公开宣传，但是也已有100多位同学信任我，跟着我在精进爬虫技术。</p>\n<p>今年 virjar 大佬加入，我俩一起做这个爬虫课，目标是做一套成体系和有竞争力的爬虫高阶课。</p>\n<p>\xa0</p>\n<p><strong>| 课程内容 |</strong></p>\n<p>爬虫技术进阶体现在反爬对抗和规模化抓取上。</p>\n<p>目前网页的对抗难度上限是跟浏览器特征绑定的高度混淆 JS 和验证码拖拽等；APP 的加固，SO 混淆，抓包和风控特征检测等。</p>\n<p>这套爬虫课程内容涉及反混淆极具难度的 JS 和拖拽验证码；以及 APP 的 HOOK 抓取，安卓容器虚拟化技术做设备指纹对抗和安卓群控抓取技术。</p>\n<p>课程还包含爬虫工程化经验，诸如规模化抓取优化窍门，社会工程，还有我们实战经验总结的一点点黑科技。</p>\n<p>\xa0</p>\n<p><strong>| 额外内容 |</strong></p>\n<p>在上述课程之外，猿人学·爬虫高阶课内容还额外做有爬虫简历写作技巧，面试和利用爬虫技术挣被动收入的实践经验和方法论。</p>\n<p>大部分简历写作上都不合格，如何写一份合格的爬虫简历，增加面试邀约机率是一个技巧。</p>\n<p>还包含我过去几年利用爬虫技术结构化数据整合做流量挣钱的实践经验和实践方法论。</p>\n<p>\xa0</p>\n<p><strong>| 获得的权益 |</strong></p>\n<p>进入猿人学内部学习群</p>\n<p>提供远程模拟面试辅导</p>\n<p>提供爬虫技术问题指导</p>\n<p>优先提供爬虫外包项目</p>\n<p>现在内部群已有100多个同学，分布在数十个城市，我们希望做成一个互帮互助的学习组织，在群里相互交流指导技术，找工作，职场等问题。</p>\n<p>我自己还会提供面试指导，以后工作中的技术问题我也提供指导。</p>\n<p>\xa0</p>\n<p><strong>| 课程提纲 |</strong></p>\n<p><img src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/crawler-course.jpg" alt="猿人学爬虫进阶课提纲"/></p>\n<p><strong>| 课程形式 |</strong></p>\n<p>视频录播，一共50节，每节平均90分钟，目前已更新40节。</p>\n<p>视频是动态更新的，有过期的内容或有更好的技术方案，就会重新制作对应视频。</p>\n<p>\xa0</p>\n<p><strong>| 适合人群 |</strong></p>\n<p>有爬虫基础，想找爬虫工作或已有爬虫工作，想技术再进阶的同学。</p>\n<p>感兴趣的同学可以扫下面二维码，购买。</p>\n<p>也可以点击此连接，进入有赞购买</p>\n<p><a href="https://detail.youzan.com/show/goods?alias=2okabph85ypv1&amp;activity_alias=undefined">https://detail.youzan.com/show/goods?alias=2okabph85ypv1&amp;activity_alias=undefined</a></p>\n<p><img class="rich_pages js_insertlocalimg" title="正式把爬虫高阶课放在网课平台了" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress9-1589809618.jpeg" alt="正式把爬虫高阶课放在网课平台了"/></p>\n<p>你也可以扫码进入详情页，注册成为分销员，把该课程分销出去，每成一单有200多元的现金奖励。</p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '我跟 virjar 出了一套爬虫课（猿人学·爬虫高阶培训课），包含：安卓逆向抓取、JS 高阶逆向抓取、安卓群控抓取、容器定制化等。实...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (21, '某文APP逆向抓取分析', 1, 2, 'https://www.lujianxin.com//media/blog/cover/linux-cover.jpg', 1, '<p>本篇来自跟我精进爬虫技术的同学（包子xia）投稿，文章的条理逻辑和对逆向工具使用，分析思路都很熟练。有苏州或南京的老板看上的，可以联系我噢，有潜力的爬虫工程师一枚。</p>\n<p>在学习了一段时间的爬虫逆向后，正好有需求要采集某某文书的一些数据，因此就以此app为例，给大家介绍一下如何使用frida找加密代码的思路，从而实现自动化采集。特此说明，本文仅供学习交流，请勿用作其他用途。</p>\n<p><strong>主要使用的工具和环境如下：</strong><br/>\n设备：一部root的手机或者手机模拟器（本人使用nexus6p真机）;<br/>\n抓包工具：fiddler；<br/>\n分析工具：jadx-gui 1.1.0；<br/>\n脱壳工具：xposed+fdex2；<br/>\n执行代码: pycharm + python3.6；<br/>\nhook框架：frida；</p>\n<p><strong>抓包初步分析</strong></p>\n<p>首先手机与电脑连在同一个网络，设置好代理和端口，打开fiddler，运行手机app，我们随意搜索某个关键词查看下抓包结果：</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1588914079.png" alt="某文APP逆向抓取分析"/></p>\n<p>从上图我们可以看出他是发出一个post请求，data是一个以request=开头的一长串加密字符，返回值是由两部分组成，一个serectkey，一个content。我们再输入一个不同的关键词，抓包得到结果与这次结果进行对比。</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914079.png" alt="某文APP逆向抓取分析"/></p>\n<p>由于参数不是很多，就不借用对比差异工具了。对比两张图，我们可以很明显得到以下几点信息：<br/>\n1.请求的url不发生改变；<br/>\n2.headers这部分没有加密；<br/>\n3.post请求的data部分是改变的，全是由字母和数字组成，初步观察有点像base64；<br/>\n4.返回值部分 初步猜测 content是由serectkey钥匙解密得到，可能是aes、des等等加密；<br/>\n由上面初步分析，我们就有方向去找加密的代码。主要寻找的就是request=后面那部分到底是什么东西，返回值是由什么加密而成的。</p>\n<p><strong>请求参数java代码分析</strong></p>\n<p>我们使用xposed+fdex2进行脱壳，得到dex源码（这边就不演示过程了），发现只有一个dex，看来app还是挺轻量级的。</p>\n<p>小tips：因为这边只有一个dex文件，所以源代码肯定在内。如果有多个dex文件的话，建议先从文件最大的那个开始排查，这样会节省点时间。<br/>\n使用jadx打开dex文件，点击导航-&gt;搜索文本。从上文分析来看，我们该搜索request这个关键词，看看能不能返回一些结果。</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1588914079.png" alt="某文APP逆向抓取分析"/></p>\n<p>发现搜索结果又200多个，要么一个个去排查，实在是太浪费时间，要么换个搜索方式。其实经常查看源码的小伙伴，可能会对变量赋值这一块搜索比较有经验，通常这种字符串，都会以以下几种方式去搜索：<br/>\n“request”<br/>\n“request”:<br/>\n“request”,<br/>\n使用上面的全文搜索，我们可以很快定义到代码赋值的地方，</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1588914079.png" alt="某文APP逆向抓取分析"/></p>\n<p>我们点击进去查看，发现调用了com.lawyee下面的b方法，传进去的参数是str.getBytes()，因此我们首先想知道传进去的值是什么，发现上文在g.b这一块调用了了str，经过查看可知，g.b就是一个log函数，输出日志用的，我们通过firda hook这一块方法，可以查看str是什么。hook代码如下</p>\n<p><code>Java.perform(function(){</code><br/>\n<code>varAndroidLog=Java.use("android.util.Log")</code><br/>\n<code>varAndroidException=Java.use("java.lang.Exception")</code><br/>\n<code>function printStackTrace(){</code><br/>\n<code>        console.log(AndroidLog.getStackTraceString(AndroidException.$new()));</code><br/>\n<code>}</code><br/>\n<code>varMainActivity=Java.use(\'com.lawyee.***.util.g\');</code><br/>\n<code>MainActivity.b.overload(\'java.lang.String\',\'java.lang.String\').implementation =function(params1,params2){</code><br/>\n<code>        send("Hook Start...")</code><br/>\n<code>//send("stack"+printStackTrace())</code><br/>\n<code>        send("params1:"+params1)</code><br/>\n<code>        send("params2:"+params2)</code><br/>\n<code>var result =this.b(params1,params2)</code><br/>\n<code>        send("result"+result)</code><br/>\n<code>}</code><br/>\n<code>});</code><br/>\n<img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914079-1.png" alt="某文APP逆向抓取分析"/></p>\n<p>其实从这边我们就可以看出，str就是request加密前的明文。经过多次输入不同关键词，可以得知一下几个关键信息：<br/>\nid 是变化的，经观察和时间有关；<br/>\ncommand = 固定参数；<br/>\npageNum = 页数；<br/>\npageSize = 一页显示的数量<br/>\nsortFields = “s50:desc” 固定参数；<br/>\nciphertext = 变化的，需要找到其加密方式；<br/>\npageSize = 每页的个数，可自行构造；<br/>\ndevid = 猜想是设备id，不发生改变；<br/>\nqueryCondition = [{“key”:”s21”,”value”:”小米”}] # 关键词 + 搜索文本的类型；<br/>\n下面我们就需要构造这些参数，组成完整的请求data，主要是两个参数ciphertext 以及id，又开始我们的全局搜索大法，发现在这里对ciphertext和id赋值。</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress10-1588914080.png" alt="某文APP逆向抓取分析"/><br/>\n<img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1588914080.png" alt="某文APP逆向抓取分析"/></p>\n<p>ciphertext = d.a();<br/>\nid 相当于是当前年月日小时分钟和秒组合而成，可构造;<br/>\n我们进入d.a()，发现代码有点长，这一块我们使用frida.rpc去调用，写一个web服务，每次请求的使用调用一次这个方法。<br/>\n<code>rpc.exports ={</code><br/>\n<code>    getsig:function(){</code><br/>\n<code>var ciphertext ="";</code><br/>\n<code>Java.perform(function(){</code><br/>\n<code>            send("here")</code><br/>\n<code>varMainActivity=Java.use(\'com.lawyee.****.util.d\');</code><br/>\n<code>            ciphertext =MainActivity.a()</code><br/>\n<code>})</code><br/>\n<code>return ciphertext</code><br/>\n<code>}</code><br/>\n<code>};</code></p>\n<p>走到这一步，我们已经可以实现自动化构造参数，下面就是要找到如何加密得到request，从文章开始我们猜测使用的base64。机智的我就把加密后的request经过base64.decode() 发现和我们构造的参数一模一样，这样就可以实现请求获取数据了。还有一种方法就是去也是用rpc调用c.a().b方法，实现获取post data。这边我选择直接使用base64。</p>\n<p><code>req_url =\'http://127.0.0.1:5001/getsigs?data={}\'.format("11")# 请求web服务获取ciphertext</code><br/>\n<code>response = requests.get(req_url)# ciphertext</code><br/>\n<code>id = time.strftime("%Y%m%d%H%M%S")</code><br/>\n<code>pagenum =1</code><br/>\n<code>pageSize =20#</code><br/>\n<code>keyword ="小米"# 关键词</code><br/>\n<code>ori_data ={"id":"%s"% id,"command":"queryDoc","params":{"pageNum":"%s"% str(pagenum),"sortFields":"s50:desc","ciphertext":"%s"% get_cipher(),"devtype":"1","devid":"5b1a4e4ffdf54c4996b00b6f57ae14f9","pageSize":"%s"% str(pageSize),"queryCondition":[{"key":"s21","value":"%s"% keyword}]}}</code><br/>\n<code>bytes_data = json.dumps(ori_data).encode("utf-8")# 二进制</code><br/>\n<code>str_data = base64.b64encode(bytes_data)# 被编码的参数必须是二进制数据</code><br/>\n<code>data ="request="+str_data.decode()# 加密后的参数</code></p>\n<p>由此我们就用python实现了的请求，得到加密前的数据。</p>\n<p><strong>返回结果加密解析</strong></p>\n<p>哈哈哈，又开始我们的猜测大法，所有加密全靠猜。一个key，一个加密后的content，让人浮想联翩。一般开发app不会自己去写一个加密算法，那样太浪费时间并且消耗成本了。其实百度搜索java常用的加密算法，我们就可以大概猜出来答案，后面无非就是一个一个去全局搜索。我们首先排除base64、MD5，这些不需要key值，常用到key值的就是des和aes这两种了，在java中，调用这两类算法需要使用调用这两个类，我们投机取巧全局搜索了一下发现了新大陆!!!</p>\n<p><code>import javax.crypto.Cipher;</code><br/>\n<code>import javax.crypto.SecretKey;</code><br/>\n<img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914080.png" alt="某文APP逆向抓取分析"/></p>\n<p>上图中，m.a(str,str1,str2)是des3加密函数，m.b是解密函数，大概看下这一部分的代码，只需要知道iv是偏移量，使用上面第一个a方法返回而来（yyyyMMdd年月日），key就是请求返回的值，content也是，我们使用frida hook一下</p>\n<p><code>Java.perform(function(){</code><br/>\n<code>varMainActivity=Java.use(\'com.lawyee.***.util.m\');</code><br/>\n<code>MainActivity.b.overload(\'java.lang.String\',\'java.lang.String\',\'java.lang.String\').implementation =function(params1,params2,params3){</code><br/>\n<code>        send("Hook Start... here7")</code><br/>\n<code>        send("params1:"+params1)</code><br/>\n<code>        send("params2:"+params2)</code><br/>\n<code>        send("params3:"+params3)</code><br/>\n<code>var result =this.b(params1,params2,params3)</code><br/>\n<code>        send("result:"+result)</code><br/>\n<code>return result</code><br/>\n<code>}</code><br/>\n<code>});</code><br/>\n<img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1588914080-1.png" alt="某文APP逆向抓取分析"/></p>\n<p>params1 就是请求返回的content<br/>\nparams2 是key<br/>\nparams3 是iv(偏移量)<br/>\nresult 是的des3解密后的结果<br/>\n到此为止，所有的加密都已经找出来啦，本来准备把des3这段代码考出来的用java执行，不过想起来之前对该网页端网站写爬虫的时候，用python实现了des3加密，今天也算用上了。</p>\n<p><code>fromCryptodome.Cipherimport DES3</code><br/>\n<code>fromCryptodome.Util.Paddingimport unpad</code><br/>\n<code>def des3decrypt(cipher_text, key, iv):</code><br/>\n<code>    des3 = DES3.new(key=key.encode(), mode=DES3.MODE_CBC, iv=iv.encode())</code><br/>\n<code>    decrypted_data = des3.decrypt(base64.b64decode(cipher_text))</code><br/>\n<code>    plain_text = unpad(decrypted_data, DES3.block_size).decode()</code><br/>\n<code>return plain_text</code><br/>\n<code><br/>\n</code></p>\n<p>这样子就可以完整的构造请求了并且获得数据了，我们尝试请求了一下，获得的结果如下：</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914080-1.png" alt="某文APP逆向抓取分析"/></p>\n<p>感兴趣的童鞋可以自己去尝试一下，整体不是很难哦。</p>\n<p><strong>总结</strong></p>\n<p>这个app从刚拿到手到解密结束，没有什么特别的坑，比较适合新手去练练手。主要的就是找到自己hook代码的思路以及找加密方法的一些小技巧。此app还没有涉及到so层面上的调用，难度下降了不少。</p>\n<p>总结起来就是如果平常逆向app的时候遇到加密参数比较多的，不要慌张，一步一步去找到加密地址的所在，合理的利用frida hook技巧，靠打印参数能够得到不少有效信息。逆向app一定要多练习，这样才能在实践中找到自己的不懂之处，才能够成长。好啦，今天的逆向小文章就到此结束啦，童鞋们下篇文章再见咯。</p>\n<p>PS：<br/>\n我出了一套爬虫高阶课程，包含：安卓/JS 逆向抓取，大规模爬虫框架设计和爬虫工程经验。感兴趣的点击这下面链接：</p>\n<p><a href="https://www.yuanrenxue.com/crawler/crawler-course.html" target="_blank" rel="noopener">我出了一套爬虫高阶学习课</a></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本篇来自跟我精进爬虫技术的同学（包子xia）投稿，文章的条理逻辑和对逆向工具使用，分析思路都很熟练。有苏州或南京的老板看上的，...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (22, 'Android 7.0 Https抓包单双向验证解决方案汇总', 1, 2, 'https://www.lujianxin.com//media/blog/cover/linux-cover.jpg', 1, '<p>这篇是跟我精进爬虫技术的小伙伴的实操总结文投稿，一篇标准的安卓7抓包指南。</p>\n<p>因为App对设备限制的原因，换了一台 Android 7 的测试机，在这期间又遇上了几种棘手的检测与验证。感觉采用防抓包技术的厂商越发多了起来。解决完这些问题，写一篇日志来记录一下，作为日后排查手册。</p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress3-1586442650.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总1"/></p>\n<p>Android 7.0 之后，默认情况下 app 只信任系统级别的 CA 。从 chls.pro/ssl 安装的证书是在用户级，这导致了 Charles 无法拦截应用流量。有两种方法可以绕过：</p>\n<p>（一）将 Charles CA 安装为系统级 CA ，需要修改 /system 权限，全局 APP 生效，需 Root</p>\n<p>（二）修改 APP 包 Androidmanifest 文件并重打包，仅针对单一APP生效，无需 root</p>\n<p>\xa0</p>\n<p><strong>第一种操作，基于 ADB shell 安装证书，需要 Root ：</strong></p>\n<p>\xa0</p>\n<p><strong>第二种操作，基于修改 Manifest 重新打包 APK，免Root :</strong></p>\n<p>原理是当 platformBuildVersionCode&gt;=24 时候，App 就只信任系统级别的CA。修改 apk 中的AndroidManifest 强行降底运行环境的 API Level ，虽然麻烦，但这种方案的存在意义是，目标APP 有设备 Root 检测时适用。</p>\n<p>运行 Apktool 反解，Android Studio 打开 AndroidManifest.xml ，目标 API 级别会在文件的 “manifest” 元素的 “platformBuildVersionCode” 属性中指定。将 platformBuildVersionCode=26改成 23 ，使用 apktool 重新打包签名安装，就可以正常抓包了。</p>\n<p>流程：<br/>\napktool反解<br/>\n修改AndroidManifest.xml<br/>\napktool 打包<br/>\nkeytool 生成证书<br/>\njarsigner apk签名<br/>\n如果有签名校验，jadx分析修改smali绕过<br/>\n<img title="Android 7.0 Https抓包单双向验证解决方案汇总2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress2-1586442650.jpeg" alt="Android 7.0 Https抓包单双向验证解决方案汇总2"/></p>\n<p>（一）App单向验证APP 内置校验证书，即厂商将证书文件或证书值内置在 APK 安装包内，通信请求时 app 自身通过代码来校验证书和服务器的关系，即 SSL Pinning 。有2种解决方案：</p>\n<p>1.逆向 App 取出证书，导入到抓包程序中</p>\n<p>证书通常在 /assets 里<br/>\njadx 反编译后搜索 .p12 .pem .cer ssl 等关键词<br/>\nHook 监听证书读取位置<br/>\n——-实例暂略，有空另起一篇专门写扣证书——-</p>\n<p>\xa0</p>\n<p>2. Hook 绕过证书的校验逻辑</p>\n<p>JustTrustMe（Root+Xposed）<br/>\nDroidSSLUnpinning(Root/免Root+Frida)</p>\n<p>JustTrustMe 在测试过程中并不顺利，首先安装时需要依赖 Xposed 框架，如果目标采用xposed 检测，会引发新的问题。并且 JustTrustMe 在某些 App 的新版本已失效，只能分析旧版本 app 或等待作者更新。用法简单，安装后 xposed 勾选启动，重启手机。</p>\n<p>DroidSSLUnpinning 在 Root 和非 Root 环境下都可以工作，Root 环境下操作更方便一些：<br/>\n确认本地环境已安装 frida&amp;frida-tools<br/>\n确认测试机 cpu 架构，https://github.com/frida/frida/releases\xa0下载对应的frida-server–&gt;</p>\n<p>部署到手机并执行–&gt;</p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress7-1586442651.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总3"/></p>\n<p>tcp 转发，用于与 frida-server 通信,之后的每个端口对应每个注入的进程</p>\n<p>本地 DroidDrops 目录下执行</p>\n<p><code>frida -U com.zhiliaoapp.musically --no-pause -l hooks.js</code></p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress2-1586442651.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总4"/></p>\n<p>启动 App，charles 抓包恢复正常。</p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress0-1586442651.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总5"/></p>\n<p>（二）App双向验证APP 双向校验，即服务器要认证请求涞源是否真实客户端（来自真实证书），大概原理这样：</p>\n<p>app –&gt;服务端（证书）—- ok<br/>\napp（证书）&lt;–服务端—- ok</p>\n<p>解决两个技术点：</p>\n<p>APP 以为 Charles 是服务端（ Hook 绕过）<br/>\n服务端以为 Charles 是客户端 （逆向 APP ，获得证书导入到 charles ）</p>\n<p>非常见证书校验技术的通杀解决方案</p>\n<p>ssl_logger 的作用原理是 hook 底层 ssl_read 和 ssl_write 两个方法，完全不用配置代理，不用理解 APP 客户端和服务端的证书校验问题。</p>\n<p>大黑阔5alt发布过一个魔改版本，精品中的精品。<br/>\nhttps://github.com/5alt/ssl_logger</p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress8-1586442651.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总6"/><br/>\n<img title="Android 7.0 Https抓包单双向验证解决方案汇总7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress3-1586442652.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总7"/></p>\n<p><strong>PS：建了一个猿人学·爬虫技术交流群，加我微信，备注：猿人学，拉你进群</strong></p>\n<p><img class="" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398733.jpeg" width="252" height="252" alt="Android 7.0 Https抓包单双向验证解决方案汇总"/></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '这篇是跟我精进爬虫技术的小伙伴的实操总结文投稿，一篇标准的安卓7抓包指南。因为App对设备限制的原因，换了一台 Android 7 的测...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (23, 'APP爬虫-双向认证抓包的两种方法', 1, 2, 'https://www.lujianxin.com//media/blog/cover/prometheus.png', 1, '<p>APP抓包相对繁琐，越来越多的 APP 在 https 请求和响应时，为了防止中间人攻击（或中间人抓包），会做证书认证，让抓包工具抓不到请求。</p><p><img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/Mutual-authentication.jpeg" alt="双向认证抓包"/></p><p>证书认证分单向认证和双向认证，双向认证是相较于单向认证而言的，单向认证就是只在 APP 侧做证书校验，单向认证有现成的解决方法，比如用各种 bypass ssl 校验的 hook 脚本既可让单向认证失效，例如：JustTrustMe 。如果 APP 的网络请求库有混淆，上述 bypass ssl 脚本无效，也有开源作者开发了自适配的 bypass 程序，可以 hook 混淆后的网络库。比如：JustMePlush 。</p><p>简单说了下单向认证如何解决，开始说双向认证如何解决。</p><p>双向认证除了要在 APP 侧做证书校验外， 对方服务端还要做证书校验。对方服务端是要检测证书的，不提交真正的证书给服务端，肯定会请求失败。</p><p>\xa0</p><p><strong>双向认证抓包有两种解决方法：</strong></p><p>一是：按照搞定证书的思路去想的话，就是要想办法拿到真正的证书。<br/>二是：Hook SSL 对数据解密数据的地方。</p><p>\xa0</p><p style="text-align: center;"><strong>方法一：</strong></p><p>因为 APP 能正常跟服务端通信，所以真正的证书肯定是在 APP 里面。所以就是要想办法从 APP 里抠出证书。抠证书有开源的 Frida Hook 脚本。如下地址是开源作者写的 Frida Hook 脚本<br/>https://gist.github.com/ceres- c/cb3b69e53713d5ad9cf6aac9b8e895d2gfgg<br/>可以把证书从内存里读出来保存到本地，并且证书密码也能读出来，非常的方便。</p><p><strong>该脚本的原理是：</strong><br/>因为 APP 在向服务端发请求时， APP 肯定会操作证书，所以如果能找到 APP 操作证书的代码地方， Hook 这部分代码，对参数做些输出打印，证书和证书密码就都有了。</p><p>大部分情况下，我们不用非常熟悉安卓原理，比如安卓在代码层面是如何操作证书的（当然熟悉更好）。因为资讯发达，一般灵活借助搜索引擎，灵活查阅资料，可以大体知道这些，就可以尝试去写 Hook 脚本去尝试看看。</p><p>查阅资料可以知道，安卓操作证书通常是 java.security.KeyStore 这个类，然后再了解下这个类的用法，参数形式。就可以尝试去 Hook 了。上述脚本就是 Hook java.security.KeyStore 这个类的 load 方法，load 方法的形参就是我们需要的证书和密码。</p><p>抠出的证书和密码，配置进 fiddler 或 charles 里面，就可以抓到双向认证的包。<br/>PS： 还要注意证书的格式，抠出的证书可能是 jks 或 bks 格式的，fiddler 可能需要 p12 格式的， 所以要找工具先转换一下格式。</p><p>\xa0</p><p style="text-align: center;"><strong>方法二：</strong></p><p>如果只是想抓包，还有另一种方法，不需要抠证书的方法。虽然 https 在传输过程中是加密的，但在终端显示的时候，必然会解密，不然 APP 上都没法显示了。所以如果能知道安卓解密 SSL 加解密是哪个类， Hook 这个类， 类里相关方法的输入输出肯定就是传输的明文数据。</p><p>所以可以查阅资料，看看相关类的用法，就可以尝试去 Hook 打印输出看看情况。也有开源作者开源了该 Hook 脚本， 比如 5alt 老板在google开源的脚本基础上做了修改了的 ssl_logger 。<br/>https://github.com/5alt/ssl_logger</p><p>能够 Hook SSL 加解密的地方，它会把传输的数据保存为 pcap 格式。再使用 wireshark 打开该 pcap文件， 在 wireshark 上就可以看到明文的数据了。</p><p>如果要模拟向服务器发送请求的话，还是只能使用第一种方法，因为客服端必须要提交正确的证书，服务端才会正确响应。必须得抠出证书，模拟请求时必须带上证书，才能请求到数据。安卓上的证书好多是 jks/bks格式的， 如果使用 Python requests 库的话， 不支持这个格式， 所以要想办法把证书转成 cert 格式的。</p><p>上面两种方法都是使用 Frida 进行 Hook ，所以要有 Root 过的手机和明白Frida 怎么使用就能搞定。</p><p>对于爬虫来说，搞定抓包和请求参数加密的问题，大部分 Hook ，都可以通过 Hook 安卓系统 API 来找到 APP 代码位置，或直接搞定。其实很少人能很熟悉安卓系统的各种原理，大部分时候能灵活通过各种关键字能查到相关原理的讲解文献，文献里讲的 API 灵活点拿去 Hook 康康线索，就能搞定很多拉。</p><p>其实使用双向认证的 APP 还是少数， 对服务器性能多少有影响。</p><p>\xa0</p><p><strong><span style="color: #00ff00;">PS ：建了一个爬虫技术和爬虫技术做副业交流群， 可以扫我私人微信（dismissmewp）加入，备注：猿人学 。</span></strong></p><p><img class="" src="https://www.yuanrenxue.com/wp-content/uploads/2019/11/personal-wechat.jpg" alt="personal wechat" width="246" height="246"/></p><p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'APP抓包相对繁琐，越来越多的 APP 在 https 请求和响应时，为了防止中间人攻击（或中间人抓包），会做证书认证，让抓包工具抓不到请...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (24, 'Protobuf协议逆向解析-APP爬虫', 1, 2, 'https://www.lujianxin.com//media/blog/cover/CPU-cover.png', 1, '<p>在做APP抓取时，会发现有的APP Response回来的数据有“加密”。不知道返回的内容是什么。</p>\n<p>本文偏长，理论基础偏多。</p>\n<p>如下：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398723.jpg" alt="APP爬虫之-Protobuf协议逆向解析"/><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress2-1583398724.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>如上，内容不是明文的，没办法解析数据。</p>\n<p>APP常见的对数据加密有三种情况：</p>\n<p>第一种是，用诸如AES这类加密算法对数据加密，然后在APP里用key进行解密，这类的数据解密的难度不是很大，弄清楚是用的什么加密算法就能反解。</p>\n<p>第二种是，用“私有”协议把数据序列化，只有了解该协议的细节才有可能把数据反序列化出来。这个的难度较大，没有功底，头发撸白都不一定撸出来。游戏和大厂APP盛行搞一个自己的私有协议来交换数据。</p>\n<p>第三种是，用第三方厂商的协议来数据序列化，自己搞不出来私有协议的就选用第三方厂商的。比如用 Google 的 Protobuf ，来做数据序列化，也就是数据“加密”。</p>\n<p><strong>今天聊的就是第三种，Protobuf 的数据反解析。</strong></p>\n<p>先来看一个 Protobuf ，做数据序列化的直观例子。</p>\n<p>比如一个 APP 的 Response 原先是以 json 格式返回的：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398725.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>这样很容易被解析，用Protobuf把上面数据序列化再传输就变成类似这样：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398725-1.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>这张图片只是样例这样就没法直接解析数据，如果了解 Protobuf 协议的话就能加快反解速度。</p>\n<p>所以还得从头来聊 Protobuf 。</p>\n<p>\xa0</p>\n<p>Protobuf 是 Google 开发的一套数据存储传输协议，跟 xml 和 json 一样的，都是用来储存和传输数据的。\xa0因为 Protobuf 能够把数据压缩得很小，所以传输数据就比 xml 和 json 快几倍，Protobuf 解析数据的速度也比它两快，所以在数据网络传输上，用 Protobuf 而不用 json 就有点受欢迎了。</p>\n<p>不过 Protobuf 储存、压缩、传输效率比 json 好，付出的代价就是用法麻烦，不像 json.loads() json.dumps()\xa0一下就搞定了这么简单。Protobuf 有一套自己的语法。不了解 Protobuf 协议语法和用法的话也无法反解数据。</p>\n<p><strong>先了解下 Protobuf 序列化和反序列化的整个流程：</strong></p>\n<p><strong>1.1.先定义一个 Protobuf\xa0语法文件（\xa0.proto 文件）</strong></p>\n<p>该语法文件用来说明要传输哪些字段、字段的数据类型、数据间的嵌套关系这些。比如一个APP要返回的数据有电话号码，姓名，年龄这三个字段，你就需要把这三个字段定义在 .proto 文件里，并且指明他们的数据类型，比如姓名和电话是字符串， 年龄是整型。</p>\n<p><strong>1.2.使用 Protobuf 提供的工具编译该语法文件。</strong></p>\n<p>用工具编译 .proto 文件的目的是，把 .proto 文件编译成代码，工具会根据该 .proto 文件自动生产代码。\xa0这个代码就是用来做数据序列化和反序列化的。</p>\n<p><strong>1.3.服务端用第2步中的代码，把“明文”数据序列化，变成“密文”后，返回给APP。</strong></p>\n<p><strong>1.4. APP 客户端用第2步中的代码，把“密文”数据反序列化，就“解密”成明文拉。</strong></p>\n<p>理论说多了很迷糊，再整个完整的直观例子：</p>\n<p>2.1.先配置 Protobuf 环境https://github.com/protocolbuffers/protobuf/releases/</p>\n<p>在 Google 官方 github 地址下载 Protobuf \xa0。</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress8-1583398725.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>下载一个 Protobuf 编译器和一个调用编译器的接口程序，我们这里用Python版的。如上图，箭头所示，解压 protoc.win64.zip 里有个 protoc 命令就是编译器。PS：注意要给 protoc 配置上环境变量，不然没法全局调用该命令。</p>\n<p>解压 protobuf-python-3.11.4.zip 这是Python模块，cd到python目录里运行 Python setup.py build 和 Python setup.py install 安装Python模块。Python编辑器里运行 import google.protobuf 可以检测是否安装成功。</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress4-1583398726.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>\xa0</p>\n<p>example目录里有官方写好的Python示例程序 和\xa0示例 .proto文件。</p>\n<p>2.2.写一个 .proto\xa0语法文件语法文件怎么写，要根据具体的传输数据来定制，</p>\n<p>比如按照 example 里的示例，如果要传输的数据是如下格式：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress6-1583398730.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>那么定义的 .proto 语法文件就如下：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress6-1583398731.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>这样就定义好了一个 .proto 语法文件，语法文件如何定义要根据传输数据的不同而变。更全的 protobuf 语法 可以看这个，有网友翻译成了中文版的。https://colobu.com/2017/03/16/Protobuf3-language-guide/</p>\n<p>2.3.使用第一步中下载的 protoc 编译器来编译 .proto 文件</p>\n<p>protoc –python_out=. addressbook.proto</p>\n<p>上述表示把 addressbook.proto 文件编译成Python版的。如果文件语法错误，在编译的时候会有提示。编译完后，会多出一个.py文件</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress1-1583398731.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>\xa0</p>\n<p>我们就可以调用这个 .py 来序列化上面的数据。2.4.开始序列化数据</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress5-1583398732.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>\xa0</p>\n<p>print里输出的就是序列化（“加密”）后的数据。2.5.对序列化后的数据进行反序列化（“解密”）</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398732.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>\xa0</p>\n<p>反序列化就把数据又还原啦。</p>\n<p>上述过程就是一个完整的正向数据 protobuf 序列化过程。我们可以看出来，主要是定义一个 .proto 文件，然后把它编译生成代码。\xa0后面就主要用这个代码来做序列化和反序列化工作。</p>\n<p>\xa0</p>\n<p>正向过程比较轻松，因为对方即有 .proto 文件，也有序列化代码，也知道要传输的数据样式。但是逆向这个过程，APP里是没有 .proto文件的，APP里是有反序列化的代码，但是看得也头晕。那该怎么办呢？</p>\n<p>借助工具，我们使用上面下载的protoc编译工具，这个工具提供反解析参数</p>\n<p>protoc –decode_raw &lt; people.bin</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398732.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>如上，使用 –decode_raw 参数就能把序列化后的数据，反序列化（解密）出来。上面只是把数据还原了，那如果我们要完全把 .proto 文件也还原出来该怎么办呢？</p>\n<p>如果 APP 发送 request 的数据要先序列化后再发送给服务端的话，那爬虫要做的事情就不只反序列化，还要能序列化。做序列化是一个正向的过程，按照上面流程，必须先要有 .proto 文件才行。</p>\n<p>所以继续还原 .proto 文件，还原 .proto 是个体力活和细致活。就是参照反解析出来的数据，还原出 .proto 文件。</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress9-1583398733.jpg" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>上面这张图是关键，看懂了就能还原出来。上图左边是反解析出来的数据，中中间是参照左边写出来的 .proto 文件，右边是人家原本的 .proto 文件。左边和中间图对比可以看出，就是根据左边的字段，挨个把字段重新定义出来就OK啦。</p>\n<p>遇到\xa0“{” 就定义一个message。中间和右边图对比可以看出，变量的名字是无关紧要的，数据类型还原正确就行。变量赋值的那些1，2，3是标识号，message里同一层级的标识号不能重复，一般是按照变量顺序从1开始递增。标识号的数字是个关键，数字写错了反解析出来的数据会不对。这样就把 .proto 文件还原出来了，然后按照正向流程又去编译，就可以使用它去序列化（“加密”）和反序列化（“解密”）APP数据了。</p>\n<p>\xa0</p>\n<p><strong>APP逆向抓取相关阅读</strong></p>\n<p><a href="https://www.yuanrenxue.com/app-crawl/app-crawl-1.html" target="_blank" rel="noopener">爬虫之-某生鲜APP加密参数逆向分析</a></p>\n<p><a href="https://www.yuanrenxue.com/crawler/frida-call-so-directly.html" target="_blank" rel="noopener">搞定某APP的TCP抓包，并实现Hook抓取</a></p>\n<p><a href="https://www.yuanrenxue.com/crawler/crawl-app-frida-rpc.html" target="_blank" rel="noopener">不还原token算法抓取APP最简单的Hook方法</a></p>\n<p>\xa0</p>\n<p><strong>PS: 再广而告之一声</strong></p>\n<p>我有在系统性的教爬虫技术APP逆向抓取技术JS高阶逆向技术群控抓取技术</p>\n<p>利用爬虫技术年挣10万被动收入的思维和实践方法如果你想爬虫技术进阶，或找一份不错的爬虫工作，我想是能够有帮助的。感兴趣可以加我私人微信，备注：学习。PS，费用不便宜，非诚勿扰。</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398733.jpeg" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '在做APP抓取时，会发现有的APP Response回来的数据有“加密”。不知道返回的内容是什么。本文偏长，理论基础偏多。如下：如上，内...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (25, '爬虫之-某生鲜APP加密参数逆向分析', 1, 2, 'https://www.lujianxin.com//media/blog/cover/cloud-cover.jpg', 1, '<p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本文是跟我学习爬虫的小伙伴：彭良怀的投稿，稿费是500。本文写得非常好，完全可以当着APP逆向抓取的教程来学。从逆向思路的分析，...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (15, 'APP 中的 JS 加密逆向解析', 1, 2, 'https://www.lujianxin.com//media/blog/cover/CPU-cover.png', 1, '<p>APP 加载 JS 的逆向解析方法</p>\n<p><strong>抓取登录包</strong></p>\n<p>解决安全检测</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress5-1601444181.png" alt="APP 中的 JS 加密逆向解析1"/></p>\n<p>\xa0</p>\n<p>使用木木模拟器，安装好app刚准备愉快的抓个包。竟然检测到root，不能进入。那就先把这个给他hook掉。</p>\n<p>用jadx打开apk，全局搜索一下，提示的文字。</p>\n<p>\xa0</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1601444181.png" alt="APP 中的 JS 加密逆向解析2"/></p>\n<p>\xa0</p>\n<p>可以看到这里进行了几种检测，编写frida hook代码，直接把 initCheckSafe 方法置空</p>\n<p>\xa0</p>\n<p>解决完毕，我们再进入app</p>\n<p>\xa0</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444181.png" alt="APP 中的 JS 加密逆向解析3"/></p>\n<p>又提示要跟新，事是真的多。那就更新吧。点击更新后，加载了一些东西，然后进入了登录页面。（!!! 后面发现这里的坑）</p>\n<p>\xa0</p>\n<p><strong>抓包分析</strong></p>\n<p>\xa0</p>\n<p>配置好代理，直接抓包。<br/>\n可以看到请求的数据模式都是<br/>\naction=xxxx&amp;data=json</p>\n<p>\xa0</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1601444181-1.png" alt="APP 中的 JS 加密逆向解析4"/></p>\n<p>\xa0</p>\n<p>把这个json数据拿出来看看，多尝试几次发现密码不变这个password不变，其他的参数都可以写死。到这里，如果账号少的话，手动抓一次包后续使用就可以了。但是咱能满足于此吗，盘它！</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444182.png" alt="APP 中的 JS 加密逆向解析5" width="219.07072pt" height="453.6pt"/></p>\n<p>\xa0</p>\n<p><strong>寻找加密位置</strong></p>\n<p><strong>盲狙碰运气</strong></p>\n<p>这个参数看着像是，某种加密后base64的结果。先base64解码看看啥情况。将加密后的值urldecode之 \xa0 \xa0后再base64解码</p>\n<p><img title="APP 中的 JS 加密逆向解析6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444182.png" alt="APP 中的 JS 加密逆向解析6" width="443.29172pt" height="273.6pt"/></p>\n<p>\xa0</p>\n<p>一堆乱码看不懂。那我们使用南山大佬写的xposed的模块把常见加密hook一波，尝试快速定位。激活xposed plus模块，然后打开ddms，查看日志信息。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444182.jpeg" alt="APP 中的 JS 加密逆向解析7" width="432.9008pt" height="200.02496pt"/></p>\n<p><img title="APP 中的 JS 加密逆向解析8" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress6-1601444182.jpeg" alt="APP 中的 JS 加密逆向解析8" width="447.6163pt" height="203.80496pt"/></p>\n<p>\xa0</p>\n<p>可以看到常见的加密类都被hook到了，但是在保存的日志中尝试搜索输入的密码，抓包的加密结果等， 都一无所获。</p>\n<p>\xa0</p>\n<p><strong>搜索反编译代码</strong></p>\n<p>\xa0</p>\n<p>看来好事多磨，快的不行那我们去分析代码吧。</p>\n<p>尝试搜索 登录链接 登录参数字段值等，都寻找不到有用的信息，事情好像陷入了僵局。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析9" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444183.png" alt="APP 中的 JS 加密逆向解析9" width="441.38245pt" height="337.1775pt"/></p>\n<p>\xa0</p>\n<p><strong>巧计寻出路</strong></p>\n<p>\xa0</p>\n<p>静静思考一会，回想到登录接口参数data后面的值是一个json类型，也就是字典类型。那能不能hook java中这个类，看看有没有password赋值的操作</p>\n<p>百度一波，得到如下hook代码</p>\n<p>\xa0</p>\n<p>把这代码灵活运用一下，我们再登录一次看看结果。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析10" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444183.png" alt="APP 中的 JS 加密逆向解析10" width="444.48254pt" height="236.85748pt"/></p>\n<p>\xa0</p>\n<p>果然发现了赋值操作，那就过滤一下无用的信息，再把这个操作的调用栈打印出来，顺藤摸瓜，那不就 \xa0能找到加密位置了嘛。感觉看到了希望。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析11" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444183-1.png" alt="APP 中的 JS 加密逆向解析12" width="406.83118pt" height="291.45pt"/></p>\n<p>\xa0</p>\n<p>还好调用栈不是很多，去掉 java开头的和proxy，剩下的我们从上面开始一个个看一下，有没有加密的地方。</p>\n<p>一直找到最下面这个方法,参数可以看到是从 exec 这个函数的参数传来的。那么hook这个exec的入参看一下。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析13" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析13" width="445.2466pt" height="290.7pt"/></p>\n<p>\xa0</p>\n<p>hook 结果：</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析14" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress7-1601444184.png" alt="APP 中的 JS 加密逆向解析14" width="444.75pt" height="54.75pt"/></p>\n<p>\xa0</p>\n<p>这下蒙蔽了，都追到根了，咋还是加密过的值呢。</p>\n<p>\xa0</p>\n<p><strong>再肯硬骨头</strong></p>\n<p><strong>发现线索一</strong></p>\n<p>有困难但是也不能放弃。再自己端详一下exec的代码，发现它头部有个@JavascriptInterface好像装饰 器一样的东西，和别的函数都不一样。<br/>\n不懂咱就去搜索一下，然后发现这个是可以让 js 和 java 互相调用的一个东西。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析15" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析15" width="443.7912pt" height="76.259926pt"/></p>\n<p>\xa0</p>\n<p>那就知道方向了，加密是在js中进行的，然后js中调用java里的exec方法，将值传了进来。</p>\n<p>将apk反编译，先去找找那些js中，有cbPassInfo setOfflineCache这些信息。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析16" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析16" width="444.78873pt" height="172.51495pt"/></p>\n<p>\xa0</p>\n<p>哟呵，搜到了这两个里面有。把他俩拖出来瞅一瞅。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析17" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析17" width="443.59882pt" height="127.170006pt"/></p>\n<p>\xa0</p>\n<p>在 login.js 里面只有这两处。先验证一下这里是不是传加密值的地方。</p>\n<p>我把这里的 cbPassInfo 改成别的字符串，然后重新打包签名apk，安装，再抓取一次登录包，如果出现的是我修改的字符，那说明这就是调用的位置。</p>\n<p>信心满满，又抓了一次包。结果啪啪打脸。还是 cbPassInfo 。</p>\n<p>\xa0</p>\n<p><strong>发现线索二</strong></p>\n<p>突然想到，重新安装打开后，有个提示框，更新资源，难道它又重新下载了这个文件，把我修改的重置 \xa0了。</p>\n<p>卸载，重装后，抓包查看下它更新的资源，发现果然是这样。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析18" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184.png" alt="APP 中的 JS 加密逆向解析18" width="447.34598pt" height="175.77pt"/></p>\n<p>\xa0</p>\n<p>既然修改apk不行，js又是静态文件，那直接在模拟器中搜索login.js<br/>\n结果有3，4个，把文件重命名，app打开没了登录界面，那就是它了。</p>\n<p>\xa0</p>\n<p><strong>模拟加密</strong></p>\n<p><strong>分析js</strong></p>\n<p>先分析一下js，密码就是通过蓝框两个方法加密的。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析19" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184-1.jpeg" alt="APP 中的 JS 加密逆向解析19" width="445.2799pt" height="176.46pt"/></p>\n<p>\xa0</p>\n<p>先搜索一下 D 和 Base64，Base64没有获得有效的信息。发现D应该和 sha1 有关系</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析20" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444185.jpeg" alt="APP 中的 JS 加密逆向解析20" width="443.6568pt" height="133.91992pt"/></p>\n<p>\xa0</p>\n<p>这里js不好调试，我们利用js调用java的流程，把我们想要的值传给java层，然后去hook接收的函数。这 \xa0 \xa0 \xa0里把我把用到的函数，各种结果都打印了一下。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析21" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1601444185.png" alt="APP 中的 JS 加密逆向解析21" width="444.0pt" height="134.25pt"/></p>\n<p><img title="APP 中的 JS 加密逆向解析22" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1601444185.jpeg" alt="APP 中的 JS 加密逆向解析22" width="449.93283pt" height="96.36pt"/></p>\n<p>\xa0</p>\n<p>这个D刚才看是和sha1相关的，用标准的sha1对比一下。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析23" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444185.png" alt="APP 中的 JS 加密逆向解析23" width="443.68427pt" height="162.36pt"/></p>\n<p>发现和上面结果相同。那就只剩base64这个函数了。看打印出来的代码，发现这不是一个标准的base64，运行报错缺少 c 变量。</p>\n<p>搜素函数内的代码，在common.js中发现了</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析24" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444185-1.png" alt="APP 中的 JS 加密逆向解析24" width="443.46616pt" height="72.54pt"/></p>\n<p>\xa0</p>\n<p>现在逻辑清楚了，把c的值拿过来，用js来实现加密。可以看到结果和抓包一致，收工。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析25" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444185.jpeg" alt="APP 中的 JS 加密逆向解析25" width="444.00867pt" height="179.7pt"/></p>\n<p>\xa0</p>\n<p><strong>总结</strong></p>\n<p>之前遇到的app都是在java代码中加密，或者 so库里面。在js中的这是第一次遇到。</p>\n<p>幸运的是js没有做处理，如果把web端的反扒应用在这，手机端又不好对js进行调试，那真是够秃头的了，可怕。</p>\n<p>这篇来自小伙伴 ID: 浮生 的投稿。</p>\n<p>安利下偶的爬虫逆向进阶课，包含 安卓逆向抓取/安卓群控/JS逆向抓取/爬虫框架设计与工程经验，国庆时正好学习下，目前熟悉安卓逆向抓取技术拿个20K+ 的 offer 还是容易。</p>\n<p><strong>具体点击下面连接</strong></p>\n<p><a href="https://www.yuanrenxue.com/crawler/crawler-course.html" target="_blank" rel="noopener">我出了一套爬虫高阶学习课</a></p>\n<p>\xa0</p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'APP 加载 JS 的逆向解析方法抓取登录包解决安全检测\xa0使用木木模拟器，安装好app刚准备愉快的抓个包。竟然检测到root，不...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (7, 'APP 中的 JS 加密逆向解析', 1, 2, 'https://www.lujianxin.com//media/blog/cover/UTF-8.png', 1, '<p>APP加载JS的逆向解析方法</p><p><strong>抓取登录包</strong></p><p>解决安全检测</p><p><imgclass="rich_pagesjs_insertlocalimg"title="APP中的JS加密逆向解析1"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress5-1601444181.png"alt="APP中的JS加密逆向解析1"/></p><p></p><p>使用木木模拟器，安装好app刚准备愉快的抓个包。竟然检测到root，不能进入。那就先把这个给他hook掉。</p><p>用jadx打开apk，全局搜索一下，提示的文字。</p><p></p><p><imgclass="rich_pagesjs_insertlocalimg"title="APP中的JS加密逆向解析2"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1601444181.png"alt="APP中的JS加密逆向解析2"/></p><p></p><p>可以看到这里进行了几种检测，编写fridahook代码，直接把initCheckSafe方法置空</p><p></p><p>解决完毕，我们再进入app</p><p></p><p><imgclass="rich_pagesjs_insertlocalimg"title="APP中的JS加密逆向解析3"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444181.png"alt="APP中的JS加密逆向解析3"/></p><p>又提示要跟新，事是真的多。那就更新吧。点击更新后，加载了一些东西，然后进入了登录页面。（!!!后面发现这里的坑）</p><p></p><p><strong>抓包分析</strong></p><p></p><p>配置好代理，直接抓包。<br/>可以看到请求的数据模式都是<br/>action=xxxx&amp;data=json</p><p></p><p><imgclass="rich_pagesjs_insertlocalimg"title="APP中的JS加密逆向解析4"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1601444181-1.png"alt="APP中的JS加密逆向解析4"/></p><p></p><p>把这个json数据拿出来看看，多尝试几次发现密码不变这个password不变，其他的参数都可以写死。到这里，如果账号少的话，手动抓一次包后续使用就可以了。但是咱能满足于此吗，盘它！</p><p></p><p><imgtitle="APP中的JS加密逆向解析5"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444182.png"alt="APP中的JS加密逆向解析5"width="219.07072pt"height="453.6pt"/></p><p></p><p><strong>寻找加密位置</strong></p><p><strong>盲狙碰运气</strong></p><p>这个参数看着像是，某种加密后base64的结果。先base64解码看看啥情况。将加密后的值urldecode之后再base64解码</p><p><imgtitle="APP中的JS加密逆向解析6"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444182.png"alt="APP中的JS加密逆向解析6"width="443.29172pt"height="273.6pt"/></p><p></p><p>一堆乱码看不懂。那我们使用南山大佬写的xposed的模块把常见加密hook一波，尝试快速定位。激活xposedplus模块，然后打开ddms，查看日志信息。</p><p></p><p><imgtitle="APP中的JS加密逆向解析7"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444182.jpeg"alt="APP中的JS加密逆向解析7"width="432.9008pt"height="200.02496pt"/></p><p><imgtitle="APP中的JS加密逆向解析8"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress6-1601444182.jpeg"alt="APP中的JS加密逆向解析8"width="447.6163pt"height="203.80496pt"/></p><p></p><p>可以看到常见的加密类都被hook到了，但是在保存的日志中尝试搜索输入的密码，抓包的加密结果等，都一无所获。</p><p></p><p><strong>搜索反编译代码</strong></p><p></p><p>看来好事多磨，快的不行那我们去分析代码吧。</p><p>尝试搜索登录链接登录参数字段值等，都寻找不到有用的信息，事情好像陷入了僵局。</p><p></p><p><imgtitle="APP中的JS加密逆向解析9"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444183.png"alt="APP中的JS加密逆向解析9"width="441.38245pt"height="337.1775pt"/></p><p></p><p><strong>巧计寻出路</strong></p><p></p><p>静静思考一会，回想到登录接口参数data后面的值是一个json类型，也就是字典类型。那能不能hookjava中这个类，看看有没有password赋值的操作</p><p>百度一波，得到如下hook代码</p><p></p><p>把这代码灵活运用一下，我们再登录一次看看结果。</p><p></p><p><imgtitle="APP中的JS加密逆向解析10"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444183.png"alt="APP中的JS加密逆向解析10"width="444.48254pt"height="236.85748pt"/></p><p></p><p>果然发现了赋值操作，那就过滤一下无用的信息，再把这个操作的调用栈打印出来，顺藤摸瓜，那不就能找到加密位置了嘛。感觉看到了希望。</p><p></p><p><imgtitle="APP中的JS加密逆向解析11"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444183-1.png"alt="APP中的JS加密逆向解析12"width="406.83118pt"height="291.45pt"/></p><p></p><p>还好调用栈不是很多，去掉java开头的和proxy，剩下的我们从上面开始一个个看一下，有没有加密的地方。</p><p>一直找到最下面这个方法,参数可以看到是从exec这个函数的参数传来的。那么hook这个exec的入参看一下。</p><p></p><p><imgtitle="APP中的JS加密逆向解析13"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444184.jpeg"alt="APP中的JS加密逆向解析13"width="445.2466pt"height="290.7pt"/></p><p></p><p>hook结果：</p><p></p><p><imgtitle="APP中的JS加密逆向解析14"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress7-1601444184.png"alt="APP中的JS加密逆向解析14"width="444.75pt"height="54.75pt"/></p><p></p><p>这下蒙蔽了，都追到根了，咋还是加密过的值呢。</p><p></p><p><strong>再肯硬骨头</strong></p><p><strong>发现线索一</strong></p><p>有困难但是也不能放弃。再自己端详一下exec的代码，发现它头部有个@JavascriptInterface好像装饰器一样的东西，和别的函数都不一样。<br/>不懂咱就去搜索一下，然后发现这个是可以让js和java互相调用的一个东西。</p><p></p><p><imgtitle="APP中的JS加密逆向解析15"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444184.jpeg"alt="APP中的JS加密逆向解析15"width="443.7912pt"height="76.259926pt"/></p><p></p><p>那就知道方向了，加密是在js中进行的，然后js中调用java里的exec方法，将值传了进来。</p><p>将apk反编译，先去找找那些js中，有cbPassInfosetOfflineCache这些信息。</p><p></p><p><imgtitle="APP中的JS加密逆向解析16"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184.jpeg"alt="APP中的JS加密逆向解析16"width="444.78873pt"height="172.51495pt"/></p><p></p><p>哟呵，搜到了这两个里面有。把他俩拖出来瞅一瞅。</p><p></p><p><imgtitle="APP中的JS加密逆向解析17"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444184.jpeg"alt="APP中的JS加密逆向解析17"width="443.59882pt"height="127.170006pt"/></p><p></p><p>在login.js里面只有这两处。先验证一下这里是不是传加密值的地方。</p><p>我把这里的cbPassInfo改成别的字符串，然后重新打包签名apk，安装，再抓取一次登录包，如果出现的是我修改的字符，那说明这就是调用的位置。</p><p>信心满满，又抓了一次包。结果啪啪打脸。还是cbPassInfo。</p><p></p><p><strong>发现线索二</strong></p><p>突然想到，重新安装打开后，有个提示框，更新资源，难道它又重新下载了这个文件，把我修改的重置了。</p><p>卸载，重装后，抓包查看下它更新的资源，发现果然是这样。</p><p></p><p><imgtitle="APP中的JS加密逆向解析18"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184.png"alt="APP中的JS加密逆向解析18"width="447.34598pt"height="175.77pt"/></p><p></p><p>既然修改apk不行，js又是静态文件，那直接在模拟器中搜索login.js<br/>结果有3，4个，把文件重命名，app打开没了登录界面，那就是它了。</p><p></p><p><strong>模拟加密</strong></p><p><strong>分析js</strong></p><p>先分析一下js，密码就是通过蓝框两个方法加密的。</p><p></p><p><imgtitle="APP中的JS加密逆向解析19"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184-1.jpeg"alt="APP中的JS加密逆向解析19"width="445.2799pt"height="176.46pt"/></p><p></p><p>先搜索一下D和Base64，Base64没有获得有效的信息。发现D应该和sha1有关系</p><p></p><p><imgtitle="APP中的JS加密逆向解析20"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444185.jpeg"alt="APP中的JS加密逆向解析20"width="443.6568pt"height="133.91992pt"/></p><p></p><p>这里js不好调试，我们利用js调用java的流程，把我们想要的值传给java层，然后去hook接收的函数。这里把我把用到的函数，各种结果都打印了一下。</p><p></p><p><imgtitle="APP中的JS加密逆向解析21"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1601444185.png"alt="APP中的JS加密逆向解析21"width="444.0pt"height="134.25pt"/></p><p><imgtitle="APP中的JS加密逆向解析22"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1601444185.jpeg"alt="APP中的JS加密逆向解析22"width="449.93283pt"height="96.36pt"/></p><p></p><p>这个D刚才看是和sha1相关的，用标准的sha1对比一下。</p><p></p><p><imgtitle="APP中的JS加密逆向解析23"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444185.png"alt="APP中的JS加密逆向解析23"width="443.68427pt"height="162.36pt"/></p><p>发现和上面结果相同。那就只剩base64这个函数了。看打印出来的代码，发现这不是一个标准的base64，运行报错缺少c变量。</p><p>搜素函数内的代码，在common.js中发现了</p><p></p><p><imgtitle="APP中的JS加密逆向解析24"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444185-1.png"alt="APP中的JS加密逆向解析24"width="443.46616pt"height="72.54pt"/></p><p></p><p>现在逻辑清楚了，把c的值拿过来，用js来实现加密。可以看到结果和抓包一致，收工。</p><p></p><p><imgtitle="APP中的JS加密逆向解析25"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444185.jpeg"alt="APP中的JS加密逆向解析25"width="444.00867pt"height="179.7pt"/></p><p></p><p><strong>总结</strong></p><p>之前遇到的app都是在java代码中加密，或者so库里面。在js中的这是第一次遇到。</p><p>幸运的是js没有做处理，如果把web端的反扒应用在这，手机端又不好对js进行调试，那真是够秃头的了，可怕。</p><p>这篇来自小伙伴ID:浮生的投稿。</p><p>安利下偶的爬虫逆向进阶课，包含安卓逆向抓取/安卓群控/JS逆向抓取/爬虫框架设计与工程经验，国庆时正好学习下，目前熟悉安卓逆向抓取技术拿个20K+的offer还是容易。</p><p><strong>具体点击下面连接</strong></p><p><ahref="https://www.yuanrenxue.com/crawler/crawler-course.html"target="_blank"rel="noopener">我出了一套爬虫高阶学习课</a></p><p></p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'APP 加载 JS 的逆向解析方法抓取登录包解决安全检测\xa0使用木木模拟器，安装好app刚准备愉快的抓个包。竟然检测到root，不...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (8, '安卓逆向之Luac解密反编译', 1, 2, 'https://www.lujianxin.com//media/blog/cover/CPU-cover.png', 1, '<p>本文阐述针对Cocos2dx-lua提供的轻量级加密方案的反编译。</p><p>本文demo对象：</p><p><imgtitle="安卓逆向之Luac解密反编译1"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress1-1600222829.png"alt="安卓逆向之Luac解密反编译1"/></p><p>lua文件大概分3种。lua是明文代码，直接用ide能打开，luac是lua编译后的字节码，文件头特征为0x1B0x4C0x750x610x51。</p><p>lua虚拟机直接解析lua和luac脚本文件，luaJIT是另一个lua的实现版本，采用即时解析运行机制，luaJIT更高效，文件头特征为0x1B0x4C0x4A。</p><p><strong>加密流程</strong></p><p>一篇文章搞定Cocos2dx-lua正向开发打包流程：</p><p>CSDN文章【Cocos2dx-lua3.11.1】打包lua项目为安卓apk</p><p>https://blog.csdn.net/lannan91/article/details/67637373/</p><p>加密指令：cocosluacompile-s未加密源码目录-d加密后源码目录-e-k加密key-b加密sign–disable-compile<br/>“</p><p><strong>解密逻辑</strong></p><p>lua官方加解密实现方式很容易就能查找资料得到，根据得到key和sign就可以利用xxtea算法来对脚本进行解密，只需要三个条件，文件路径&amp;加密sign&amp;加密key就能解密。<br/>加密和解密算法在这：<br/>https://github.com/cocos2d/cocos2d-x-3rd-party-libs-bin/tree/v3/xxtea</p><p><strong>实现过程</strong></p><p>加密sign的找寻方法sign在.luac文件头中<br/>随机打开一个项目内的.luac文件，找第一个字符串。</p><p><imgtitle="安卓逆向之Luac解密反编译2"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress5-1600222829.jpeg"alt="安卓逆向之Luac解密反编译2"/></p><p></p><p><strong>加密key的找寻方法</strong></p><p>key在打包后的cocos的lib库的libcocos2dlua.so中<br/>1.第一种方法是libcocos2dlua.so使用IDApro打开，全局查找加密sign。点击进入查找结果，在该结果的上方3行能够发现加密key。<br/>2.第二种方法，由于写作的电脑已经升级到10.15.5(19F101)，IDApro运行有问题。所以用osx自带的strings工具查找。<br/>2-1.终端运行strings-alibcocos2dlua.so<br/>2-2.ctrl+f查找sign，观察sign上方的字符串，即为key。</p><p><imgtitle="安卓逆向之Luac解密反编译3"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1600222829.png"alt="安卓逆向之Luac解密反编译3"/></p><p><strong>解密实现</strong></p><p>OSX实现脚本：<br/>https://github.com/dengxiaochun/luac_decodeToolwin实现工具：<br/>https://www.jb51.net/softs/575428.htmlOSX演示：<br/>将解密脚本放在项目assets目录下</p><p><imgtitle="安卓逆向之Luac解密反编译4"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1600222830.png"alt="安卓逆向之Luac解密反编译4"/></p><p>修改decode.sh的SIGN&amp;KEY变量，并保存。</p><p><imgtitle="安卓逆向之Luac解密反编译5"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress1-1600222831.png"alt="安卓逆向之Luac解密反编译5"/></p><p>终端执行：sh./decode.shsrc</p><p><imgtitle="安卓逆向之Luac解密反编译6"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1600222831.png"alt="安卓逆向之Luac解密反编译6"/></p><p>执行结果：</p><p><imgtitle="安卓逆向之Luac解密反编译7"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1600222832.png"alt="安卓逆向之Luac解密反编译7"/></p><p></p><p>执行后脚本将自动备份luac源代码（src_backup）</p><p><imgtitle="安卓逆向之Luac解密反编译8"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1600222833.png"alt="安卓逆向之Luac解密反编译8"/></p><p>解密后的.lua文件在src目录中，ide打开，源代码反编译成功，可以进一步研究程序的客户端源码实现。</p><p><imgtitle="安卓逆向之Luac解密反编译9"src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress10-1600222834.png"alt="安卓逆向之Luac解密反编译9"/></p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本文阐述针对Cocos2dx-lua提供的轻量级加密方案的反编译。本文demo对象：lua文件大概分3种。lua是明文代码，直接用ide能打开，lu...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (9, '巧破某报价大全APP加密参数-iOS逆向抓取', 1, 2, 'https://www.lujianxin.com//media/blog/cover/internet-cover.jpg', 1, '<p>iOS作为一种闭源系统，没有Android那么多的packers和so库，iOS官方封装了自己统一的Crypto库，所以我们HOOK起来也很方便。我以某报价大全iOSv10.5.5版为例，记录一下巧破加密参数的过程和一些知识点。</p><p>此次逆向教程使用到的工具如下：</p><p>一部越狱iPhone或iPad</p><p>抓包工具：Charles</p><p>Hook框架：fridav12.8.11</p><p>通过Charles抓取目标APP列表页请求的数据，我们发现含有32位的“sign”参数，且向下滑动加载更多时“sign”参数都会变化。两次抓包请求参数对比如下图：</p><p><imgtitle="iOS逆向抓取-巧破某报价大全APP加密参数1"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress3-1591693046.png"alt="iOS逆向抓取-巧破某报价大全APP加密参数1"/></p><p>通过对比抓包数据，我们猜测可能使用了MD5加密算法，接下来我们就用frida-trace监控iOS系统封装的CC_MD5加密函数，看能不能巧破该APP的“sign”参数。</p><p>首先通过frida-ps-Ua（请自行安装frida）查看目标APP的进程id为4934：<br/><imgtitle="iOS逆向抓取-巧破某报价大全APP加密参数2"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591693046.png"alt="iOS逆向抓取-巧破某报价大全APP加密参数2"/></p><p></p><p>再通过frida-trace跟踪“CC_MD5”函数，命令如下：</p><p><imgtitle="iOS逆向抓取-巧破某报价大全APP加密参数3"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress9-1591693046.png"alt="iOS逆向抓取-巧破某报价大全APP加密参数3"/></p><p></p><p>frida-trace参数说明如下：</p><p>-U使用USB数据线连接设备</p><p>-i追踪函数</p><p>“CC_MD5”要追踪的函数名</p><p>4934目标APP进程id</p><p>接着在终端界面按Ctrl+C停止运行。然后在__handlers__/ASEProcessing文件夹中找到CC_MD5.js文件，将代码修改为如下并保存：</p><p><imgtitle="iOS逆向抓取-巧破某报价大全APP加密参数4"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress6-1591693046.png"alt="iOS逆向抓取-巧破某报价大全APP加密参数4"/></p><p></p><p>以上代码会在追踪到CC_MD5函数步入时打印待加密的参数值，步出时打印加密后的md5返回值。<br/>接着我们继续使用之前的命令运行frida-trace，然后在目标APP列表页继续滑动即可看到frida-trace追踪到的参数和返回值。然后我们用Charles抓包看到的sign值到frida-trace窗口中搜索即可找到对应参数，如下图：</p><p><imgtitle="iOS逆向抓取-巧破某报价大全APP加密参数5"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress0-1591693047.png"alt="iOS逆向抓取-巧破某报价大全APP加密参数5"/></p><p>对比请求的url和加密参数：<br/>-请求的url：api.ashx?cateid=3&amp;cityid=&amp;method=news.list&amp;pageindex=3&amp;pagesize=25&amp;productid=7&amp;serialid=&amp;sign=fbe1c8222424f38371f0b59592a6293b-加密的参数：?cateid=3&amp;cityid=&amp;method=news.list&amp;pageindex=3&amp;pagesize=25&amp;productid=7&amp;serialid=2CB3147B-D93C-964B-47AE-EEE448C84E3C</p><p>请求url中标注部分与加密参数标注部分完全一致，我们可以确定盐值为：2CB3147B-D93C-964B-47AE-EEE448C84E3C。至此“sign”参数md5加密算法不攻自破了。</p><p><imgtitle="iOS逆向抓取-巧破某报价大全APP加密参数6"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591693047.png"alt="iOS逆向抓取-巧破某报价大全APP加密参数6"/></p><p></p><p>本文重点在通过Charles抓包看到“sign”参数为32位字符串，猜测是md5加密，从而使用frida-trace监控目标APP是否使用了iOS系统封装的CC_MD5加密函数。之后一击即中巧破了“sign”参数加密算法。</p><p>对于我们爬虫工作者在抓取数据时遇到加密“sign”参数，首先可以猜测其大致的算法，之后用frida-trace去监测系统默认的加密函数，比如iOS系统的：CC_MD5，CC_SHA1，CCHmac等，有可能会有意想不到的收获。如果此方法行不通，我们可以再去想办法逆向分析。</p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'iOS作为一种闭源系统，没有Android那么多的packers和so库，iOS官方封装了自己统一的Crypto库，所以我们HOOK起来也很方便。我以某报...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (10, 'APP爬虫-某APP iOS版逆向过程', 1, 2, 'https://www.lujianxin.com//media/blog/cover/internet-cover.jpg', 1, '<p>本篇来自周小鱼同学的投稿，跟着猿人学王平大佬学了一段时间安卓APP逆向，刚刚入门。由于我使用Mac和iOS更频繁，所以我以某汽车iOS版为例，记录一下逆向过程和一些知识点。</p><p><strong>此次逆向教程使用到的工具如下：</strong></p><p>一部越狱iPhone或iPad<br/>抓包工具：Charles<br/>反编译分析工具：IDA64_v7.0<br/>Hook框架：objectionv1.9.1<br/>https://github.com/sensepost/objection<br/>调试工具：LLDB，Debugserver</p><p>抓包发现含有32位数的“_r”参数(可能为MD5加密)以及34位数的sign参数，且每次请求都会变化。经过反复抓包对比测试，发现无论修改任何参数再提交服务器都会返回url签名错误，并且发现sign参数最后2位数不变，猜测是32位数MD5密文加字符串“01”组成。接下来的重点就是分析“sign”和“_r”是怎么生成的。</p><p>两次抓包参数文本对比效果图：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程1"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress6-1591691472.png"alt="APP爬虫-某APPiOS版逆向过程1"/></p><p>使用frida-iOS-dump一键砸壳后，将砸壳后的二进制文件拖入到IDA中进行分析。由于“sign”关键字可能存在太多干扰不利于分析，所以我们从一个可能干扰比较少的关键字“ttDna”开始分析。</p><p>在IDAstrings窗口搜索ttDna，有且只有一个结果完全吻合，如下图：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程2"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress0-1591691472.png"alt="APP爬虫-某APPiOS版逆向过程2"/></p><p>通过这个关键字，我们进入到了函数：-[CBDBaseApiextraParams]，果断使用objection（如何使用请自行查阅资料）对此函数进行hook，查看其参数、返回值和调用堆栈，截图如下：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程3"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress8-1591691473.png"alt="APP爬虫-某APPiOS版逆向过程3"/></p><p>返回值确实包含了我们抓包中看到的信息，但是不完整，需要继续追踪调用函数。</p><p>通过第一个堆栈地址0xc4ed40+IDA64头部偏移量0x100000000=0x100c4ed40找到IDA64中相应地址调用的地方，发现在函数：-[MCCBaseApibuildFullUrl:]内部。我们继续使用objection对此函数进行hook，发现返回值与我们抓包看到的完全吻合：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程4"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress4-1591691473.png"alt="APP爬虫-某APPiOS版逆向过程4"/></p><p>从上面返回值的截图可以看出完整的url是由此函数拼装而成，接下来我们在IDA64中按F5键查看该函数的伪代码，逆向由下往上分析：<br/>return=v21=v20=v14=v13，<br/>发现返回值是<br/>+[MCCURLManagerbuildUrlString:withParams:sign:]<br/>生成的：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程5"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591691473.png"alt="APP爬虫-某APPiOS版逆向过程5"/></p><p>继续追踪<br/>-[MCCURLManagerbuildUrlString:withParams:sign:]，</p><p>发现来自于<br/>-[MCCURLManagerbuildUrlString:withParams:sign:useBasicParam:usePublicParam:]。<br/>在此函数中，我们发现了“_r”参数。</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程6"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress9-1591691473.png"alt="APP爬虫-某APPiOS版逆向过程6"/></p><p>经过分析“_r”参数是随机生成的UUID经过MD5加密得到。</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程7"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress0-1591691474.png"alt="APP爬虫-某APPiOS版逆向过程7"/></p><p>继续一路追踪sign参数，发现到了一个跟sign有关的函数：+[MCCSignURLManagersignUrl1:withKey:]，果断使用objectionhook该函数，参数和返回值仅仅只多了一串sign参数，由此可以判断sign在此函数内生成，并且发现key值是：<br/>SW+SaqSibZdCmqNyh4WYlW+l，<br/>截图如下：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程8"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress9-1591691474.png"alt="APP爬虫-某APPiOS版逆向过程8"/></p><p>继续分析该函数的伪代码，我们看到一个自定义的函数SignUrl1，如下图：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程9"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress3-1591691474.png"alt="APP爬虫-某APPiOS版逆向过程9"/></p><p>双击进入SignUrl1，我们又看到另一个自义定函数SignUrl0，如下图：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程10"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress10-1591691474.png"alt="APP爬虫-某APPiOS版逆向过程10"/></p><p>双击进入SignUrl0，我们看到熟悉的MD5加密算法，如下图：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程11"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress8-1591691475.png"alt="APP爬虫-某APPiOS版逆向过程11"/></p><p>逆向分析到此，我们可以大胆猜测，SignUrl1是在组装加密参数，之后将参数传递给SignUrl0进行MD5加密之后再将密文返回给SignUrl1。</p><p>现在我们只需要查看SignUrl0函数的具体参数就可以知道如何加密了。接下来我们使用LLDB+debugserver（具体如何使用请自行查阅资料）在图下位置下断点并查看传入的具体参数：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程12"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress10-1591691475.png"alt="APP爬虫-某APPiOS版逆向过程12"/></p><p>参数1为不包含sign参数部分的请求内容，部分截图如下：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程13"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress5-1591691475.png"alt="APP爬虫-某APPiOS版逆向过程13"/></p><p>参数2为key值经过base64decode等步骤转换而来的固定字符串：<br/>5oBjPRiG2ZSbwqDAoQ，<br/>也就是MD5加密的盐。这里我们无需深究key是如何转换的，只需拿到key的固定字符串即可：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程14"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress6-1591691475.png"alt="APP爬虫-某APPiOS版逆向过程14"/></p><p>所以sign参数算法就是由函数SignUrl0的入参1+入参2经MD5加密后与“01”拼接得到。接下来我们验证一下我们猜测的算法与抓包是否一致：</p><p><imgtitle="APP爬虫-某APPiOS版逆向过程15"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591691476.png"alt="APP爬虫-某APPiOS版逆向过程15"/></p><p><imgtitle="APP爬虫-某APPiOS版逆向过程16"src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress3-1591691476.png"alt="APP爬虫-某APPiOS版逆向过程16"/></p><p>由上面2张图可以看出sign参数算法完全正确，至此sign参数和“_r”参数全部告破。接下来就可以使用Python实现算法然后自由爬取文章了。</p><p>本篇文章的案例用到了Charles抓包，frida-iOS-dump砸壳，IDA64反编译，objectionHOOK框架，以及LLDB+debugserver调试等工具。每一个工具的使用都需要花大量时间研究，本文并未对以上工具的使用进行详细说明，感兴趣的同学可以自行查阅相关资料。</p><p>案例中的APP也算是大厂开发的，而我们对其二进制文件的加密函数分析并不是太难，没有对关键字加密，没有复杂的算法，也没有对函数名进行混淆，直接使用IDA64进行静态分析，以及使用objectionhook查看参数和返回值就追踪到了加密的函数。</p><p>所以做爬虫工作碰到APP逆向这个事情，首先不要害怕，其实市场上大多数APP的加密参数都可以通过我们这种方式搞定。当然很难的也有很多，比如关键字加密，函数名混淆，反调试检测，多线程循环发包，网络发包封装第三方库等等，面对这些只要有信心有耐心，多学习实操总结，慢慢积累经验，会有所成的，大家共勉！</p><p><strong>PS：广而告之：</strong><br/>把猿人学·爬虫高阶课又更新了，加入了安卓群控，详情点击<ahref="https://www.yuanrenxue.com/crawler/advance-course.html">https://www.yuanrenxue.com/crawler/advance-course.html</a></p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本篇来自周小鱼同学的投稿，跟着猿人学王平大佬学了一段时间安卓APP逆向，刚刚入门。由于我使用Mac和iOS更频繁，所以我以某汽车 iOS...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (11, '分析app的登陆协议', 1, 2, 'https://www.lujianxin.com//media/blog/cover/cloud-cover.jpg', 1, '<p>这是一篇逆向分析APP登陆流程的文章。</p><p>（1）抓包前将手机和电脑连接到同一WIFI，在手机设置好代理，装好证书，就可以开始抓包了。之前我遇到抓不到包的情况，换了几个代理工具也不行，最后是开着热点抓到包（一台开热点，另一台和电脑连接热点），或者换成手机抓包工具HttpCanary等也可以抓包。</p><p>（2）抓包环境配置好后，在登陆界面随便填一个账号密码：</p><p><imgtitle="分析app的登陆协议1"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585810.png"alt="分析app的登陆协议1"width="264.0pt"height="159.65pt"/></p><p>（3）点击登录，查看Fiddler中的数据包数据包中的参数：city=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;citycode=010&amp;device=63ac32df-d1c2-3008-828e-ef9f1bb3a96d&amp;device_model=google%20Pixel%202&amp;device_name=google%20Pixel%202&amp;device_os=Android%205.1.1&amp;device_product=google&amp;device_size=1080*1920&amp;device_type=1&amp;district=%E4%B8%9C%E5%9F%8E%E5%8C%BA&amp;fake_id=37979341&amp;interface_code=620&amp;latitude=39.91640353732639&amp;longitude=116.41024359809028&amp;mobile=13426355456&amp;password=EBEDF39355506FF1F42AAD7A20E1DB83&amp;province=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;province_code=1582770774000&amp;version=6.2.0&amp;securitykey=41de91b2c71d0af71c7a71887e14b57d</p><p>一般需要抓两次包来对比数据包参数的变化，观察哪些参数是固定或者容易得到的，哪些是不能直观看出需要进一步分析：</p><p><imgtitle="分析app的登陆协议2"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress5-1590585810.png"alt="分析app的登陆协议2"width="415.25pt"height="120.35pt"/></p><p>对比两个数据包可以看到，手机号没有加密，密码做了加密，还有一个参数securitykey也是加密的。这次逆向的重点也就是分析这两个参数的生成逻辑。</p><p>（1）直接把apk用jadx反编译，发现做了加固，是legu的壳，相关逻辑代码没法直接看到：</p><p><imgclass="rich_pages"title="分析app的登陆协议3"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress10-1590585811.png"alt="分析app的登陆协议3"/></p><p>（2）这里我使用了一个基于frida编写的脱壳工具：https://github.com/hluwa/FRIDA-DEXDump原理是在内存中暴力搜索，根据dex文件的结构特征将其dump下来，启动frida-server，启动app，运行脚本就可以了。如果使用过程中报错，可以试试重启手机，或者杀死app进程并重启app。</p><p>（1）之前抓到的包是分析的入口点，在jadx中反编译dump下来的dex，点击菜单栏的小魔法棒搜索securitykey这个参数：</p><p><imgtitle="分析app的登陆协议4"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585811.png"alt="分析app的登陆协议4"width="415.3pt"height="41.85pt"/></p><p>结果如下;第四个GLOBAL_PARAMS_KEY=“securitykey”比较显眼，双击打开看看，也可以把右边所有结果挨个点开分析：</p><p><imgclass="rich_pages"title="分析app的登陆协议5"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585811.png"alt="分析app的登陆协议5"/></p><p></p><p>观察代码，securitykey参数应该是在其他位置被引用，右键GLOBAL_PARAMS_KEY，选择查找用例，看看哪些地方用了这个参数：</p><p><imgtitle="分析app的登陆协议6"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress8-1590585811.png"alt="分析app的登陆协议6"width="415.25pt"height="161.05pt"/></p><p>根据经验推测，第二个stringBuffer.append一般是数据包参数构造的位置，双击打开它：</p><p><imgclass="rich_pages"title="分析app的登陆协议7"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress8-1590585812.png"alt="分析app的登陆协议7"/></p><p>GLOBAL_PARAMS_KEY的值就是securitykey参数，接着拼接了一个“=”和一个finalSecStr的变量</p><p><imgtitle="分析app的登陆协议8"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585812.png"alt="分析app的登陆协议8"width="415.2pt"height="110.8pt"/></p><p>双击这个finalSecStr变量，可以看到finalSecStr在代码中的处理逻辑，可以看到是经过getMD5Str这个方法处理得到的，看函数名感觉是计算MD5：</p><p><imgtitle="分析app的登陆协议9"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1590585812.png"alt="分析app的登陆协议9"width="415.2pt"height="181.6pt"/></p><p></p><p>继续看getMD5Str的参数secStr，发现是由this.paramMap处理得到：</p><p><imgtitle="分析app的登陆协议10"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585812.png"alt="分析app的登陆协议10"width="415.15pt"height="138.1pt"/></p><p>再往上分析，发现this.paramMap中值就是数据包那些参数：</p><p><imgtitle="分析app的登陆协议11"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1590585813.png"alt="分析app的登陆协议11"width="415.05pt"height="199.45pt"/></p><p>自此，securitykey这个参数的计算逻辑差不多出来了，把this.paramMap中的参数挨个拼接“|”变成secStr，再传给getMD5Str，返回的值就是数据包中securitykey的值。<br/>按住Ctrl键，单击getMD5Str这个方法，可以看到就是MD5的计算：</p><p><imgtitle="分析app的登陆协议12"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress2-1590585813.png"alt="分析app的登陆协议12"width="415.2pt"height="239.15pt"/></p><p>点击菜单栏中的向左小箭头返回上一层代码：</p><p><imgtitle="分析app的登陆协议13"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress8-1590585813.png"alt="分析app的登陆协议13"width="372.0pt"height="36.6pt"/></p><p>我们可以通过hookgetMD5Str方法，将其参数和返回值打印出来，验证我们的分析。这里涉及到一个问题，这个app加了壳，直接去hook会出现“ClassNotFoundError“的错误，这是因为getMD5Str这个方法不是一开始就在内存中的，它是被壳加载起来的。所以hook方法要有所改变。</p><p>原理：所有的类都是通过ClassLoader的loadClass方法加载的，于是可以等我们要hook的这个方法所在的类被加载后再去hook，这样就可以百发百中了，多个DEX的情况下也可以使用这个方法该方法出处：https://bbs.pediy.com/thread-225190.htm</p><p><imgtitle="分析app的登陆协议14"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585813.png"alt="分析app的登陆协议14"width="465.05pt"height="294.5pt"/></p><p>HookgetMD5Str方法后打印参数和返回值，编译安装xposed插件，重启手机，结果发现什么也没hook到，确认类名和方法名，参数都没问题。经过长时间的分析也没结论，最后是用ddms发现了问题：jadx反编译得到的类名，方法名不正确，与真实命名不一样。<br/>%1.ddms的使用ddms是一个AndroidSDK自带的方法追踪工具（一般位于SDK的tools目录下），用于记录app执行过的方法。这里我们需要记录的是点击登陆按钮后app执行的方法。打开ddms后，先选中app对应的进程，然后选择菜单栏中的“开始追踪”</p><p><imgclass="rich_pages"title="分析app的登陆协议15"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585814.png"alt="分析app的登陆协议15"/></p><p></p><p>选择第二个，记录所有方法</p><p><imgtitle="分析app的登陆协议16"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1590585814.png"alt="分析app的登陆协议16"width="381.0pt"height="207.6pt"/></p><p>接着以最快的手速点击登录按钮（因为ddms会记录系统中在运行的很多进程的方法），等到弹出“该账号不存在”（因为我们随便输入的），立即点击ddms的“停止追踪”按键（跟“开始追踪”是同一个，不过现在变灰了），就能得到从点击登陆按钮后到账号校验完期间app执行的所有方法：</p><p><imgtitle="分析app的登陆协议17"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585814.png"alt="分析app的登陆协议17"width="414.95pt"height="66.55pt"/><br/>接着会弹出一个trace文件，就是记录下来的方法：<br/><imgtitle="分析app的登陆协议18"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress2-1590585814.png"alt="分析app的登陆协议18"width="414.9pt"height="148.2pt"/></p><p>在最下面find搜索栏中输入app的包名，按回车键挨个观察记录下来的方法，在其中找到了getMD5Str方法的正确类路径，而之前在jadx中反编译得到的是：com.XXXXXX.common.utils.encrtption.MD5Helper.getMD5Str所以用jadx中的类路径肯定是hook不到getMD5Str方法了。</p><p><imgclass="rich_pages"title="分析app的登陆协议19"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585815.png"alt="分析app的登陆协议19"/></p><p></p><p>把类路径改成ddms记录的正确路径，重新编译hook插件，重启手机，运行app，输入账号密码，点击登录，在ddms的日志中可以发现，这次顺利的打印出了getMD5Str方法的参数和返回值：</p><p><imgtitle="分析app的登陆协议20"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress1-1590585815.png"alt="分析app的登陆协议20"width="509.05pt"height="157.5pt"/></p><p>对比数据包参数：</p><p><imgtitle="分析app的登陆协议21"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585815-1.png"alt="分析app的登陆协议21"width="414.9pt"height="118.95pt"/></p><p>将getMD5Str方法的参数与数据包中参数对比，发现是一致的，返回值就是参数的MD5值，验证了我们之前的分析是对的：</p><p><imgtitle="分析app的登陆协议22"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585815.png"alt="分析app的登陆协议22"width="370.8pt"height="181.85pt"/></p><p>%1.password参数的分析分析完了securitykey这个参数，现在就分析password这个参数，可以发现，并没有在大量参数构造的地方发现password：</p><p><imgtitle="分析app的登陆协议23"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585816.png"alt="分析app的登陆协议23"width="415.05pt"height="199.45pt"/></p><p>在jadx中搜索也没有发现：</p><p><imgclass="rich_pages"title="分析app的登陆协议24"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress1-1590585816.png"alt="分析app的登陆协议24"/></p><p></p><p>观察上面的参数，他们都是带着双引号的，尝试给password加上双引号搜索，终于看到了：</p><p><imgtitle="分析app的登陆协议25"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress10-1590585816.png"alt="分析app的登陆协议25"width="444.05pt"height="91.45pt"/></p><p>第二个看着像是AES加密有关的，双击进去看看，果然是：</p><p><imgtitle="分析app的登陆协议26"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585816.png"alt="分析app的登陆协议26"width="510.5pt"height="79.65pt"/></p><p>按住Ctrl，点开AesEncryptionHelper看看，是”AES/CBC/PKCS5Padding”的加密方法：</p><p><imgtitle="分析app的登陆协议27"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress9-1590585816.png"alt="分析app的登陆协议27"width="415.0pt"height="62.4pt"/></p><p>验证一下：</p><p><imgtitle="分析app的登陆协议28"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585817.png"alt="分析app的登陆协议28"width="490.75pt"height="204.6pt"/></p><p>跟数据包中的password的值是一样的：</p><p><imgtitle="分析app的登陆协议29"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585817.png"alt="分析app的登陆协议29"width="415.2pt"height="53.2pt"/></p><p>自此，两个加密参数的分析就完成了。</p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '这是一篇逆向分析APP登陆流程的文章。1. 抓包（1） 抓包前将手机和电脑连接到同一WIFI，在手机设置好代理，装好证书，就可以开始...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (12, '正式把猿人学爬虫高阶课放在网课平台了', 1, 2, 'https://www.lujianxin.com//media/blog/cover/CPU-cover.png', 1, '<p><imgclass="rich_pages"title="正式把爬虫高阶课放在网课平台了"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1589809617.jpeg"alt="正式把爬虫高阶课放在网课平台了"/><br/>我跟virjar出了一套爬虫课（猿人学·爬虫高阶培训课），包含：安卓逆向抓取、JS高阶逆向抓取、安卓群控抓取、容器定制化等。</p><p>实际上我去年就在做这个爬虫课了，一直没有放到网课平台上公开宣传，但是也已有100多位同学信任我，跟着我在精进爬虫技术。</p><p>今年virjar大佬加入，我俩一起做这个爬虫课，目标是做一套成体系和有竞争力的爬虫高阶课。</p><p></p><p><strong>|课程内容|</strong></p><p>爬虫技术进阶体现在反爬对抗和规模化抓取上。</p><p>目前网页的对抗难度上限是跟浏览器特征绑定的高度混淆JS和验证码拖拽等；APP的加固，SO混淆，抓包和风控特征检测等。</p><p>这套爬虫课程内容涉及反混淆极具难度的JS和拖拽验证码；以及APP的HOOK抓取，安卓容器虚拟化技术做设备指纹对抗和安卓群控抓取技术。</p><p>课程还包含爬虫工程化经验，诸如规模化抓取优化窍门，社会工程，还有我们实战经验总结的一点点黑科技。</p><p></p><p><strong>|额外内容|</strong></p><p>在上述课程之外，猿人学·爬虫高阶课内容还额外做有爬虫简历写作技巧，面试和利用爬虫技术挣被动收入的实践经验和方法论。</p><p>大部分简历写作上都不合格，如何写一份合格的爬虫简历，增加面试邀约机率是一个技巧。</p><p>还包含我过去几年利用爬虫技术结构化数据整合做流量挣钱的实践经验和实践方法论。</p><p></p><p><strong>|获得的权益|</strong></p><p>进入猿人学内部学习群</p><p>提供远程模拟面试辅导</p><p>提供爬虫技术问题指导</p><p>优先提供爬虫外包项目</p><p>现在内部群已有100多个同学，分布在数十个城市，我们希望做成一个互帮互助的学习组织，在群里相互交流指导技术，找工作，职场等问题。</p><p>我自己还会提供面试指导，以后工作中的技术问题我也提供指导。</p><p></p><p><strong>|课程提纲|</strong></p><p><imgsrc="https://www.yuanrenxue.com/wp-content/uploads/2020/09/crawler-course.jpg"alt="猿人学爬虫进阶课提纲"/></p><p><strong>|课程形式|</strong></p><p>视频录播，一共50节，每节平均90分钟，目前已更新40节。</p><p>视频是动态更新的，有过期的内容或有更好的技术方案，就会重新制作对应视频。</p><p></p><p><strong>|适合人群|</strong></p><p>有爬虫基础，想找爬虫工作或已有爬虫工作，想技术再进阶的同学。</p><p>感兴趣的同学可以扫下面二维码，购买。</p><p>也可以点击此连接，进入有赞购买</p><p><ahref="https://detail.youzan.com/show/goods?alias=2okabph85ypv1&amp;activity_alias=undefined">https://detail.youzan.com/show/goods?alias=2okabph85ypv1&amp;activity_alias=undefined</a></p><p><imgclass="rich_pagesjs_insertlocalimg"title="正式把爬虫高阶课放在网课平台了"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress9-1589809618.jpeg"alt="正式把爬虫高阶课放在网课平台了"/></p><p>你也可以扫码进入详情页，注册成为分销员，把该课程分销出去，每成一单有200多元的现金奖励。</p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '我跟 virjar 出了一套爬虫课（猿人学·爬虫高阶培训课），包含：安卓逆向抓取、JS 高阶逆向抓取、安卓群控抓取、容器定制化等。实...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (13, '某文APP逆向抓取分析', 1, 2, 'https://www.lujianxin.com//media/blog/cover/cloud-cover.jpg', 1, '<p>本篇来自跟我精进爬虫技术的同学（包子xia）投稿，文章的条理逻辑和对逆向工具使用，分析思路都很熟练。有苏州或南京的老板看上的，可以联系我噢，有潜力的爬虫工程师一枚。</p><p>在学习了一段时间的爬虫逆向后，正好有需求要采集某某文书的一些数据，因此就以此app为例，给大家介绍一下如何使用frida找加密代码的思路，从而实现自动化采集。特此说明，本文仅供学习交流，请勿用作其他用途。</p><p><strong>主要使用的工具和环境如下：</strong><br/>设备：一部root的手机或者手机模拟器（本人使用nexus6p真机）;<br/>抓包工具：fiddler；<br/>分析工具：jadx-gui1.1.0；<br/>脱壳工具：xposed+fdex2；<br/>执行代码:pycharm+python3.6；<br/>hook框架：frida；</p><p><strong>抓包初步分析</strong></p><p>首先手机与电脑连在同一个网络，设置好代理和端口，打开fiddler，运行手机app，我们随意搜索某个关键词查看下抓包结果：</p><p><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1588914079.png"alt="某文APP逆向抓取分析"/></p><p>从上图我们可以看出他是发出一个post请求，data是一个以request=开头的一长串加密字符，返回值是由两部分组成，一个serectkey，一个content。我们再输入一个不同的关键词，抓包得到结果与这次结果进行对比。</p><p><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914079.png"alt="某文APP逆向抓取分析"/></p><p>由于参数不是很多，就不借用对比差异工具了。对比两张图，我们可以很明显得到以下几点信息：<br/>1.请求的url不发生改变；<br/>2.headers这部分没有加密；<br/>3.post请求的data部分是改变的，全是由字母和数字组成，初步观察有点像base64；<br/>4.返回值部分初步猜测content是由serectkey钥匙解密得到，可能是aes、des等等加密；<br/>由上面初步分析，我们就有方向去找加密的代码。主要寻找的就是request=后面那部分到底是什么东西，返回值是由什么加密而成的。</p><p><strong>请求参数java代码分析</strong></p><p>我们使用xposed+fdex2进行脱壳，得到dex源码（这边就不演示过程了），发现只有一个dex，看来app还是挺轻量级的。</p><p>小tips：因为这边只有一个dex文件，所以源代码肯定在内。如果有多个dex文件的话，建议先从文件最大的那个开始排查，这样会节省点时间。<br/>使用jadx打开dex文件，点击导航-&gt;搜索文本。从上文分析来看，我们该搜索request这个关键词，看看能不能返回一些结果。</p><p><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1588914079.png"alt="某文APP逆向抓取分析"/></p><p>发现搜索结果又200多个，要么一个个去排查，实在是太浪费时间，要么换个搜索方式。其实经常查看源码的小伙伴，可能会对变量赋值这一块搜索比较有经验，通常这种字符串，都会以以下几种方式去搜索：<br/>“request”<br/>“request”:<br/>“request”,<br/>使用上面的全文搜索，我们可以很快定义到代码赋值的地方，</p><p><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1588914079.png"alt="某文APP逆向抓取分析"/></p><p>我们点击进去查看，发现调用了com.lawyee下面的b方法，传进去的参数是str.getBytes()，因此我们首先想知道传进去的值是什么，发现上文在g.b这一块调用了了str，经过查看可知，g.b就是一个log函数，输出日志用的，我们通过firdahook这一块方法，可以查看str是什么。hook代码如下</p><p><code>Java.perform(function(){</code><br/><code>varAndroidLog=Java.use("android.util.Log")</code><br/><code>varAndroidException=Java.use("java.lang.Exception")</code><br/><code>functionprintStackTrace(){</code><br/><code>console.log(AndroidLog.getStackTraceString(AndroidException.$new()));</code><br/><code>}</code><br/><code>varMainActivity=Java.use(\'com.lawyee.***.util.g\');</code><br/><code>MainActivity.b.overload(\'java.lang.String\',\'java.lang.String\').implementation=function(params1,params2){</code><br/><code>send("HookStart...")</code><br/><code>//send("stack"+printStackTrace())</code><br/><code>send("params1:"+params1)</code><br/><code>send("params2:"+params2)</code><br/><code>varresult=this.b(params1,params2)</code><br/><code>send("result"+result)</code><br/><code>}</code><br/><code>});</code><br/><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914079-1.png"alt="某文APP逆向抓取分析"/></p><p>其实从这边我们就可以看出，str就是request加密前的明文。经过多次输入不同关键词，可以得知一下几个关键信息：<br/>id是变化的，经观察和时间有关；<br/>command=固定参数；<br/>pageNum=页数；<br/>pageSize=一页显示的数量<br/>sortFields=“s50:desc”固定参数；<br/>ciphertext=变化的，需要找到其加密方式；<br/>pageSize=每页的个数，可自行构造；<br/>devid=猜想是设备id，不发生改变；<br/>queryCondition=[{“key”:”s21”,”value”:”小米”}]#关键词+搜索文本的类型；<br/>下面我们就需要构造这些参数，组成完整的请求data，主要是两个参数ciphertext以及id，又开始我们的全局搜索大法，发现在这里对ciphertext和id赋值。</p><p><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress10-1588914080.png"alt="某文APP逆向抓取分析"/><br/><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1588914080.png"alt="某文APP逆向抓取分析"/></p><p>ciphertext=d.a();<br/>id相当于是当前年月日小时分钟和秒组合而成，可构造;<br/>我们进入d.a()，发现代码有点长，这一块我们使用frida.rpc去调用，写一个web服务，每次请求的使用调用一次这个方法。<br/><code>rpc.exports={</code><br/><code>getsig:function(){</code><br/><code>varciphertext="";</code><br/><code>Java.perform(function(){</code><br/><code>send("here")</code><br/><code>varMainActivity=Java.use(\'com.lawyee.****.util.d\');</code><br/><code>ciphertext=MainActivity.a()</code><br/><code>})</code><br/><code>returnciphertext</code><br/><code>}</code><br/><code>};</code></p><p>走到这一步，我们已经可以实现自动化构造参数，下面就是要找到如何加密得到request，从文章开始我们猜测使用的base64。机智的我就把加密后的request经过base64.decode()发现和我们构造的参数一模一样，这样就可以实现请求获取数据了。还有一种方法就是去也是用rpc调用c.a().b方法，实现获取postdata。这边我选择直接使用base64。</p><p><code>req_url=\'http://127.0.0.1:5001/getsigs?data={}\'.format("11")#请求web服务获取ciphertext</code><br/><code>response=requests.get(req_url)#ciphertext</code><br/><code>id=time.strftime("%Y%m%d%H%M%S")</code><br/><code>pagenum=1</code><br/><code>pageSize=20#</code><br/><code>keyword="小米"#关键词</code><br/><code>ori_data={"id":"%s"%id,"command":"queryDoc","params":{"pageNum":"%s"%str(pagenum),"sortFields":"s50:desc","ciphertext":"%s"%get_cipher(),"devtype":"1","devid":"5b1a4e4ffdf54c4996b00b6f57ae14f9","pageSize":"%s"%str(pageSize),"queryCondition":[{"key":"s21","value":"%s"%keyword}]}}</code><br/><code>bytes_data=json.dumps(ori_data).encode("utf-8")#二进制</code><br/><code>str_data=base64.b64encode(bytes_data)#被编码的参数必须是二进制数据</code><br/><code>data="request="+str_data.decode()#加密后的参数</code></p><p>由此我们就用python实现了的请求，得到加密前的数据。</p><p><strong>返回结果加密解析</strong></p><p>哈哈哈，又开始我们的猜测大法，所有加密全靠猜。一个key，一个加密后的content，让人浮想联翩。一般开发app不会自己去写一个加密算法，那样太浪费时间并且消耗成本了。其实百度搜索java常用的加密算法，我们就可以大概猜出来答案，后面无非就是一个一个去全局搜索。我们首先排除base64、MD5，这些不需要key值，常用到key值的就是des和aes这两种了，在java中，调用这两类算法需要使用调用这两个类，我们投机取巧全局搜索了一下发现了新大陆!!!</p><p><code>importjavax.crypto.Cipher;</code><br/><code>importjavax.crypto.SecretKey;</code><br/><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914080.png"alt="某文APP逆向抓取分析"/></p><p>上图中，m.a(str,str1,str2)是des3加密函数，m.b是解密函数，大概看下这一部分的代码，只需要知道iv是偏移量，使用上面第一个a方法返回而来（yyyyMMdd年月日），key就是请求返回的值，content也是，我们使用fridahook一下</p><p><code>Java.perform(function(){</code><br/><code>varMainActivity=Java.use(\'com.lawyee.***.util.m\');</code><br/><code>MainActivity.b.overload(\'java.lang.String\',\'java.lang.String\',\'java.lang.String\').implementation=function(params1,params2,params3){</code><br/><code>send("HookStart...here7")</code><br/><code>send("params1:"+params1)</code><br/><code>send("params2:"+params2)</code><br/><code>send("params3:"+params3)</code><br/><code>varresult=this.b(params1,params2,params3)</code><br/><code>send("result:"+result)</code><br/><code>returnresult</code><br/><code>}</code><br/><code>});</code><br/><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1588914080-1.png"alt="某文APP逆向抓取分析"/></p><p>params1就是请求返回的content<br/>params2是key<br/>params3是iv(偏移量)<br/>result是的des3解密后的结果<br/>到此为止，所有的加密都已经找出来啦，本来准备把des3这段代码考出来的用java执行，不过想起来之前对该网页端网站写爬虫的时候，用python实现了des3加密，今天也算用上了。</p><p><code>fromCryptodome.CipherimportDES3</code><br/><code>fromCryptodome.Util.Paddingimportunpad</code><br/><code>defdes3decrypt(cipher_text,key,iv):</code><br/><code>des3=DES3.new(key=key.encode(),mode=DES3.MODE_CBC,iv=iv.encode())</code><br/><code>decrypted_data=des3.decrypt(base64.b64decode(cipher_text))</code><br/><code>plain_text=unpad(decrypted_data,DES3.block_size).decode()</code><br/><code>returnplain_text</code><br/><code><br/></code></p><p>这样子就可以完整的构造请求了并且获得数据了，我们尝试请求了一下，获得的结果如下：</p><p><imgtitle="某文APP逆向抓取分析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914080-1.png"alt="某文APP逆向抓取分析"/></p><p>感兴趣的童鞋可以自己去尝试一下，整体不是很难哦。</p><p><strong>总结</strong></p><p>这个app从刚拿到手到解密结束，没有什么特别的坑，比较适合新手去练练手。主要的就是找到自己hook代码的思路以及找加密方法的一些小技巧。此app还没有涉及到so层面上的调用，难度下降了不少。</p><p>总结起来就是如果平常逆向app的时候遇到加密参数比较多的，不要慌张，一步一步去找到加密地址的所在，合理的利用fridahook技巧，靠打印参数能够得到不少有效信息。逆向app一定要多练习，这样才能在实践中找到自己的不懂之处，才能够成长。好啦，今天的逆向小文章就到此结束啦，童鞋们下篇文章再见咯。</p><p>PS：<br/>我出了一套爬虫高阶课程，包含：安卓/JS逆向抓取，大规模爬虫框架设计和爬虫工程经验。感兴趣的点击这下面链接：</p><p><ahref="https://www.yuanrenxue.com/crawler/crawler-course.html"target="_blank"rel="noopener">我出了一套爬虫高阶学习课</a></p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本篇来自跟我精进爬虫技术的同学（包子xia）投稿，文章的条理逻辑和对逆向工具使用，分析思路都很熟练。有苏州或南京的老板看上的，...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (14, 'Android 7.0 Https抓包单双向验证解决方案汇总', 1, 2, 'https://www.lujianxin.com//media/blog/cover/prometheus.png', 1, '<p>这篇是跟我精进爬虫技术的小伙伴的实操总结文投稿，一篇标准的安卓7抓包指南。</p><p>因为App对设备限制的原因，换了一台Android7的测试机，在这期间又遇上了几种棘手的检测与验证。感觉采用防抓包技术的厂商越发多了起来。解决完这些问题，写一篇日志来记录一下，作为日后排查手册。</p><p><imgtitle="Android7.0Https抓包单双向验证解决方案汇总1"src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress3-1586442650.png"alt="Android7.0Https抓包单双向验证解决方案汇总1"/></p><p>Android7.0之后，默认情况下app只信任系统级别的CA。从chls.pro/ssl安装的证书是在用户级，这导致了Charles无法拦截应用流量。有两种方法可以绕过：</p><p>（一）将CharlesCA安装为系统级CA，需要修改/system权限，全局APP生效，需Root</p><p>（二）修改APP包Androidmanifest文件并重打包，仅针对单一APP生效，无需root</p><p></p><p><strong>第一种操作，基于ADBshell安装证书，需要Root：</strong></p><p></p><p><strong>第二种操作，基于修改Manifest重新打包APK，免Root:</strong></p><p>原理是当platformBuildVersionCode&gt;=24时候，App就只信任系统级别的CA。修改apk中的AndroidManifest强行降底运行环境的APILevel，虽然麻烦，但这种方案的存在意义是，目标APP有设备Root检测时适用。</p><p>运行Apktool反解，AndroidStudio打开AndroidManifest.xml，目标API级别会在文件的“manifest”元素的“platformBuildVersionCode”属性中指定。将platformBuildVersionCode=26改成23，使用apktool重新打包签名安装，就可以正常抓包了。</p><p>流程：<br/>apktool反解<br/>修改AndroidManifest.xml<br/>apktool打包<br/>keytool生成证书<br/>jarsignerapk签名<br/>如果有签名校验，jadx分析修改smali绕过<br/><imgtitle="Android7.0Https抓包单双向验证解决方案汇总2"src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress2-1586442650.jpeg"alt="Android7.0Https抓包单双向验证解决方案汇总2"/></p><p>（一）App单向验证APP内置校验证书，即厂商将证书文件或证书值内置在APK安装包内，通信请求时app自身通过代码来校验证书和服务器的关系，即SSLPinning。有2种解决方案：</p><p>1.逆向App取出证书，导入到抓包程序中</p><p>证书通常在/assets里<br/>jadx反编译后搜索.p12.pem.cerssl等关键词<br/>Hook监听证书读取位置<br/>——-实例暂略，有空另起一篇专门写扣证书——-</p><p></p><p>2.Hook绕过证书的校验逻辑</p><p>JustTrustMe（Root+Xposed）<br/>DroidSSLUnpinning(Root/免Root+Frida)</p><p>JustTrustMe在测试过程中并不顺利，首先安装时需要依赖Xposed框架，如果目标采用xposed检测，会引发新的问题。并且JustTrustMe在某些App的新版本已失效，只能分析旧版本app或等待作者更新。用法简单，安装后xposed勾选启动，重启手机。</p><p>DroidSSLUnpinning在Root和非Root环境下都可以工作，Root环境下操作更方便一些：<br/>确认本地环境已安装frida&amp;frida-tools<br/>确认测试机cpu架构，https://github.com/frida/frida/releases下载对应的frida-server–&gt;</p><p>部署到手机并执行–&gt;</p><p><imgtitle="Android7.0Https抓包单双向验证解决方案汇总3"src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress7-1586442651.png"alt="Android7.0Https抓包单双向验证解决方案汇总3"/></p><p>tcp转发，用于与frida-server通信,之后的每个端口对应每个注入的进程</p><p>本地DroidDrops目录下执行</p><p><code>frida-Ucom.zhiliaoapp.musically--no-pause-lhooks.js</code></p><p><imgtitle="Android7.0Https抓包单双向验证解决方案汇总4"src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress2-1586442651.png"alt="Android7.0Https抓包单双向验证解决方案汇总4"/></p><p>启动App，charles抓包恢复正常。</p><p><imgtitle="Android7.0Https抓包单双向验证解决方案汇总5"src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress0-1586442651.png"alt="Android7.0Https抓包单双向验证解决方案汇总5"/></p><p>（二）App双向验证APP双向校验，即服务器要认证请求涞源是否真实客户端（来自真实证书），大概原理这样：</p><p>app–&gt;服务端（证书）—-ok<br/>app（证书）&lt;–服务端—-ok</p><p>解决两个技术点：</p><p>APP以为Charles是服务端（Hook绕过）<br/>服务端以为Charles是客户端（逆向APP，获得证书导入到charles）</p><p>非常见证书校验技术的通杀解决方案</p><p>ssl_logger的作用原理是hook底层ssl_read和ssl_write两个方法，完全不用配置代理，不用理解APP客户端和服务端的证书校验问题。</p><p>大黑阔5alt发布过一个魔改版本，精品中的精品。<br/>https://github.com/5alt/ssl_logger</p><p><imgtitle="Android7.0Https抓包单双向验证解决方案汇总6"src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress8-1586442651.png"alt="Android7.0Https抓包单双向验证解决方案汇总6"/><br/><imgtitle="Android7.0Https抓包单双向验证解决方案汇总7"src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress3-1586442652.png"alt="Android7.0Https抓包单双向验证解决方案汇总7"/></p><p><strong>PS：建了一个猿人学·爬虫技术交流群，加我微信，备注：猿人学，拉你进群</strong></p><p><imgclass=""src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398733.jpeg"width="252"height="252"alt="Android7.0Https抓包单双向验证解决方案汇总"/></p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '这篇是跟我精进爬虫技术的小伙伴的实操总结文投稿，一篇标准的安卓7抓包指南。因为App对设备限制的原因，换了一台 Android 7 的测...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (15, 'APP爬虫-双向认证抓包的两种方法', 1, 2, 'https://www.lujianxin.com//media/blog/cover/prometheus.png', 1, '<p>APP抓包相对繁琐，越来越多的APP在https请求和响应时，为了防止中间人攻击（或中间人抓包），会做证书认证，让抓包工具抓不到请求。</p><p><imgsrc="https://www.yuanrenxue.com/wp-content/uploads/2020/03/Mutual-authentication.jpeg"alt="双向认证抓包"/></p><p>证书认证分单向认证和双向认证，双向认证是相较于单向认证而言的，单向认证就是只在APP侧做证书校验，单向认证有现成的解决方法，比如用各种bypassssl校验的hook脚本既可让单向认证失效，例如：JustTrustMe。如果APP的网络请求库有混淆，上述bypassssl脚本无效，也有开源作者开发了自适配的bypass程序，可以hook混淆后的网络库。比如：JustMePlush。</p><p>简单说了下单向认证如何解决，开始说双向认证如何解决。</p><p>双向认证除了要在APP侧做证书校验外，对方服务端还要做证书校验。对方服务端是要检测证书的，不提交真正的证书给服务端，肯定会请求失败。</p><p></p><p><strong>双向认证抓包有两种解决方法：</strong></p><p>一是：按照搞定证书的思路去想的话，就是要想办法拿到真正的证书。<br/>二是：HookSSL对数据解密数据的地方。</p><p></p><pstyle="text-align:center;"><strong>方法一：</strong></p><p>因为APP能正常跟服务端通信，所以真正的证书肯定是在APP里面。所以就是要想办法从APP里抠出证书。抠证书有开源的FridaHook脚本。如下地址是开源作者写的FridaHook脚本<br/>https://gist.github.com/ceres-c/cb3b69e53713d5ad9cf6aac9b8e895d2gfgg<br/>可以把证书从内存里读出来保存到本地，并且证书密码也能读出来，非常的方便。</p><p><strong>该脚本的原理是：</strong><br/>因为APP在向服务端发请求时，APP肯定会操作证书，所以如果能找到APP操作证书的代码地方，Hook这部分代码，对参数做些输出打印，证书和证书密码就都有了。</p><p>大部分情况下，我们不用非常熟悉安卓原理，比如安卓在代码层面是如何操作证书的（当然熟悉更好）。因为资讯发达，一般灵活借助搜索引擎，灵活查阅资料，可以大体知道这些，就可以尝试去写Hook脚本去尝试看看。</p><p>查阅资料可以知道，安卓操作证书通常是java.security.KeyStore这个类，然后再了解下这个类的用法，参数形式。就可以尝试去Hook了。上述脚本就是Hookjava.security.KeyStore这个类的load方法，load方法的形参就是我们需要的证书和密码。</p><p>抠出的证书和密码，配置进fiddler或charles里面，就可以抓到双向认证的包。<br/>PS：还要注意证书的格式，抠出的证书可能是jks或bks格式的，fiddler可能需要p12格式的，所以要找工具先转换一下格式。</p><p></p><pstyle="text-align:center;"><strong>方法二：</strong></p><p>如果只是想抓包，还有另一种方法，不需要抠证书的方法。虽然https在传输过程中是加密的，但在终端显示的时候，必然会解密，不然APP上都没法显示了。所以如果能知道安卓解密SSL加解密是哪个类，Hook这个类，类里相关方法的输入输出肯定就是传输的明文数据。</p><p>所以可以查阅资料，看看相关类的用法，就可以尝试去Hook打印输出看看情况。也有开源作者开源了该Hook脚本，比如5alt老板在google开源的脚本基础上做了修改了的ssl_logger。<br/>https://github.com/5alt/ssl_logger</p><p>能够HookSSL加解密的地方，它会把传输的数据保存为pcap格式。再使用wireshark打开该pcap文件，在wireshark上就可以看到明文的数据了。</p><p>如果要模拟向服务器发送请求的话，还是只能使用第一种方法，因为客服端必须要提交正确的证书，服务端才会正确响应。必须得抠出证书，模拟请求时必须带上证书，才能请求到数据。安卓上的证书好多是jks/bks格式的，如果使用Pythonrequests库的话，不支持这个格式，所以要想办法把证书转成cert格式的。</p><p>上面两种方法都是使用Frida进行Hook，所以要有Root过的手机和明白Frida怎么使用就能搞定。</p><p>对于爬虫来说，搞定抓包和请求参数加密的问题，大部分Hook，都可以通过Hook安卓系统API来找到APP代码位置，或直接搞定。其实很少人能很熟悉安卓系统的各种原理，大部分时候能灵活通过各种关键字能查到相关原理的讲解文献，文献里讲的API灵活点拿去Hook康康线索，就能搞定很多拉。</p><p>其实使用双向认证的APP还是少数，对服务器性能多少有影响。</p><p></p><p><strong><spanstyle="color:#00ff00;">PS：建了一个爬虫技术和爬虫技术做副业交流群，可以扫我私人微信（dismissmewp）加入，备注：猿人学。</span></strong></p><p><imgclass=""src="https://www.yuanrenxue.com/wp-content/uploads/2019/11/personal-wechat.jpg"alt="personalwechat"width="246"height="246"/></p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'APP抓包相对繁琐，越来越多的 APP 在 https 请求和响应时，为了防止中间人攻击（或中间人抓包），会做证书认证，让抓包工具抓不到请...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (16, 'Protobuf协议逆向解析-APP爬虫', 1, 2, 'https://www.lujianxin.com//media/blog/cover/UTF-8.png', 1, '<p>在做APP抓取时，会发现有的APPResponse回来的数据有“加密”。不知道返回的内容是什么。</p><p>本文偏长，理论基础偏多。</p><p>如下：</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398723.jpg"alt="APP爬虫之-Protobuf协议逆向解析"/><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress2-1583398724.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p>如上，内容不是明文的，没办法解析数据。</p><p>APP常见的对数据加密有三种情况：</p><p>第一种是，用诸如AES这类加密算法对数据加密，然后在APP里用key进行解密，这类的数据解密的难度不是很大，弄清楚是用的什么加密算法就能反解。</p><p>第二种是，用“私有”协议把数据序列化，只有了解该协议的细节才有可能把数据反序列化出来。这个的难度较大，没有功底，头发撸白都不一定撸出来。游戏和大厂APP盛行搞一个自己的私有协议来交换数据。</p><p>第三种是，用第三方厂商的协议来数据序列化，自己搞不出来私有协议的就选用第三方厂商的。比如用Google的Protobuf，来做数据序列化，也就是数据“加密”。</p><p><strong>今天聊的就是第三种，Protobuf的数据反解析。</strong></p><p>先来看一个Protobuf，做数据序列化的直观例子。</p><p>比如一个APP的Response原先是以json格式返回的：</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398725.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p>这样很容易被解析，用Protobuf把上面数据序列化再传输就变成类似这样：</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398725-1.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p>这张图片只是样例这样就没法直接解析数据，如果了解Protobuf协议的话就能加快反解速度。</p><p>所以还得从头来聊Protobuf。</p><p></p><p>Protobuf是Google开发的一套数据存储传输协议，跟xml和json一样的，都是用来储存和传输数据的。因为Protobuf能够把数据压缩得很小，所以传输数据就比xml和json快几倍，Protobuf解析数据的速度也比它两快，所以在数据网络传输上，用Protobuf而不用json就有点受欢迎了。</p><p>不过Protobuf储存、压缩、传输效率比json好，付出的代价就是用法麻烦，不像json.loads()json.dumps()一下就搞定了这么简单。Protobuf有一套自己的语法。不了解Protobuf协议语法和用法的话也无法反解数据。</p><p><strong>先了解下Protobuf序列化和反序列化的整个流程：</strong></p><p><strong>1.1.先定义一个Protobuf语法文件（.proto文件）</strong></p><p>该语法文件用来说明要传输哪些字段、字段的数据类型、数据间的嵌套关系这些。比如一个APP要返回的数据有电话号码，姓名，年龄这三个字段，你就需要把这三个字段定义在.proto文件里，并且指明他们的数据类型，比如姓名和电话是字符串，年龄是整型。</p><p><strong>1.2.使用Protobuf提供的工具编译该语法文件。</strong></p><p>用工具编译.proto文件的目的是，把.proto文件编译成代码，工具会根据该.proto文件自动生产代码。这个代码就是用来做数据序列化和反序列化的。</p><p><strong>1.3.服务端用第2步中的代码，把“明文”数据序列化，变成“密文”后，返回给APP。</strong></p><p><strong>1.4.APP客户端用第2步中的代码，把“密文”数据反序列化，就“解密”成明文拉。</strong></p><p>理论说多了很迷糊，再整个完整的直观例子：</p><p>2.1.先配置Protobuf环境https://github.com/protocolbuffers/protobuf/releases/</p><p>在Google官方github地址下载Protobuf。</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress8-1583398725.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p>下载一个Protobuf编译器和一个调用编译器的接口程序，我们这里用Python版的。如上图，箭头所示，解压protoc.win64.zip里有个protoc命令就是编译器。PS：注意要给protoc配置上环境变量，不然没法全局调用该命令。</p><p>解压protobuf-python-3.11.4.zip这是Python模块，cd到python目录里运行Pythonsetup.pybuild和Pythonsetup.pyinstall安装Python模块。Python编辑器里运行importgoogle.protobuf可以检测是否安装成功。</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress4-1583398726.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p></p><p>example目录里有官方写好的Python示例程序和示例.proto文件。</p><p>2.2.写一个.proto语法文件语法文件怎么写，要根据具体的传输数据来定制，</p><p>比如按照example里的示例，如果要传输的数据是如下格式：</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress6-1583398730.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p>那么定义的.proto语法文件就如下：</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress6-1583398731.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p>这样就定义好了一个.proto语法文件，语法文件如何定义要根据传输数据的不同而变。更全的protobuf语法可以看这个，有网友翻译成了中文版的。https://colobu.com/2017/03/16/Protobuf3-language-guide/</p><p>2.3.使用第一步中下载的protoc编译器来编译.proto文件</p><p>protoc–python_out=.addressbook.proto</p><p>上述表示把addressbook.proto文件编译成Python版的。如果文件语法错误，在编译的时候会有提示。编译完后，会多出一个.py文件</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress1-1583398731.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p></p><p>我们就可以调用这个.py来序列化上面的数据。2.4.开始序列化数据</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress5-1583398732.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p></p><p>print里输出的就是序列化（“加密”）后的数据。2.5.对序列化后的数据进行反序列化（“解密”）</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398732.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p></p><p>反序列化就把数据又还原啦。</p><p>上述过程就是一个完整的正向数据protobuf序列化过程。我们可以看出来，主要是定义一个.proto文件，然后把它编译生成代码。后面就主要用这个代码来做序列化和反序列化工作。</p><p></p><p>正向过程比较轻松，因为对方即有.proto文件，也有序列化代码，也知道要传输的数据样式。但是逆向这个过程，APP里是没有.proto文件的，APP里是有反序列化的代码，但是看得也头晕。那该怎么办呢？</p><p>借助工具，我们使用上面下载的protoc编译工具，这个工具提供反解析参数</p><p>protoc–decode_raw&lt;people.bin</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398732.png"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p>如上，使用–decode_raw参数就能把序列化后的数据，反序列化（解密）出来。上面只是把数据还原了，那如果我们要完全把.proto文件也还原出来该怎么办呢？</p><p>如果APP发送request的数据要先序列化后再发送给服务端的话，那爬虫要做的事情就不只反序列化，还要能序列化。做序列化是一个正向的过程，按照上面流程，必须先要有.proto文件才行。</p><p>所以继续还原.proto文件，还原.proto是个体力活和细致活。就是参照反解析出来的数据，还原出.proto文件。</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress9-1583398733.jpg"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p>上面这张图是关键，看懂了就能还原出来。上图左边是反解析出来的数据，中中间是参照左边写出来的.proto文件，右边是人家原本的.proto文件。左边和中间图对比可以看出，就是根据左边的字段，挨个把字段重新定义出来就OK啦。</p><p>遇到“{”就定义一个message。中间和右边图对比可以看出，变量的名字是无关紧要的，数据类型还原正确就行。变量赋值的那些1，2，3是标识号，message里同一层级的标识号不能重复，一般是按照变量顺序从1开始递增。标识号的数字是个关键，数字写错了反解析出来的数据会不对。这样就把.proto文件还原出来了，然后按照正向流程又去编译，就可以使用它去序列化（“加密”）和反序列化（“解密”）APP数据了。</p><p></p><p><strong>APP逆向抓取相关阅读</strong></p><p><ahref="https://www.yuanrenxue.com/app-crawl/app-crawl-1.html"target="_blank"rel="noopener">爬虫之-某生鲜APP加密参数逆向分析</a></p><p><ahref="https://www.yuanrenxue.com/crawler/frida-call-so-directly.html"target="_blank"rel="noopener">搞定某APP的TCP抓包，并实现Hook抓取</a></p><p><ahref="https://www.yuanrenxue.com/crawler/crawl-app-frida-rpc.html"target="_blank"rel="noopener">不还原token算法抓取APP最简单的Hook方法</a></p><p></p><p><strong>PS:再广而告之一声</strong></p><p>我有在系统性的教爬虫技术APP逆向抓取技术JS高阶逆向技术群控抓取技术</p><p>利用爬虫技术年挣10万被动收入的思维和实践方法如果你想爬虫技术进阶，或找一份不错的爬虫工作，我想是能够有帮助的。感兴趣可以加我私人微信，备注：学习。PS，费用不便宜，非诚勿扰。</p><p><imgtitle="APP爬虫之-Protobuf协议逆向解析"src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398733.jpeg"alt="APP爬虫之-Protobuf协议逆向解析"/></p><p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '在做APP抓取时，会发现有的APP Response回来的数据有“加密”。不知道返回的内容是什么。本文偏长，理论基础偏多。如下：如上，内...');
INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read","like","add","mod",is_active,digest) VALUES (17, '爬虫之-某生鲜APP加密参数逆向分析', 1, 2, 'https://www.lujianxin.com//media/blog/cover/CPU-cover.png', 1, '<p/><p/><p><em>我的公众号：<strong>猿人学Python</strong>上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学yuanrenxue.com原创，没有猿人学授权，请勿以任何形式转载。***</em></p><pclass="tags"/>', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本文是跟我学习爬虫的小伙伴：彭良怀的投稿，稿费是500。本文写得非常好，完全可以当着APP逆向抓取的教程来学。从逆向思路的分析，...');

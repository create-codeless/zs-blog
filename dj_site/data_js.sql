INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (7, '字符编码原理', 1, 2, '/media/blog/cover/UTF-8.png', 1, '<p><span style="font-family: 宋体, SimSun; font-size: 17px;">在计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是 Unicode，就像它的名字都表示的，这是一种所有符号的编码。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8 是 Unicode 的实现方式之一。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">UTF-8 的编码规则很简单，只有二条：</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">下表总结了编码规则，字母x表示可用编码的位。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">下面，还是以汉字严为例，演示如何实现 UTF-8 编码。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。</span></p><p><br/></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/za1adcrxwkol\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    ASCII 编码在计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以\n                ');

INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (8, 'PromQL内置函数', 1, 2, '/media/blog/cover/prometheus.png', 1, '<p><span style="font-family: 宋体, SimSun; font-size: 17px;">就如同SQL中有一些内置函数，PromQL中也存在一些函数，我们可以在进行PromQL表达式进行使用，完成一些数据的处理。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">sum</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;"> (求和)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">min</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;"> (最小值)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">max</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;"> (最大值)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">avg</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;"> (平均值)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">stddev</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;"> (标准差)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">stdvar</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;"> (标准差异)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">count </span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(样本数量计数)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">count_values</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;"> (对 value 进行计数)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">bottomk</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;"> (样本值最小的 k 个元素)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">topk</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;"> (样本值最大的k个元素)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">quantile </span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(分布统计)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">abs</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(instant-vector)\xa0 求瞬时向量绝对值</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">absent</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector)\xa0 传入一个瞬时非空向量则返回空向量，否则返回不带名称值为1的指标，用来监控空数据的情况</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">ceil</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 四舍五入取整</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">floor</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 函数与 ceil() 函数相反，舍弃小数部分取整</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">changes</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v range-vector)\xa0 计算区间向量中每个样本值变化次数，返回的是瞬时向量</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">clamp_max</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector, max scalar)\xa0 瞬时向量值如果大于max 则值修改为max，否则值不变（用于将向量规范到一个不大于max的区间内）</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">clamp_min</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector, min scalar)\xa0 同理，将向量规范到一个不小于min值的范围内</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">day_of_month</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v=vector(time()) instant-vector) 返回 1～31 向量所在UTC时间中的所在月份的第几天</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">day_of_week</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v=vector(time()) instant-vector) 函数，返回被给定 UTC 时间所在周的第几天。返回值范围：0~6，0 表示星期天。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">days_in_month</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v=vector(time()) instant-vector) 函数，返回当月一共有多少天。返回值范围：28~31。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">delta</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v range-vector) 的参数是一个区间向量，返回一个瞬时向量。它计算一个区间向量 v 的第一个元素和最后一个元素之间的差值</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">idelta</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v range-vector) 的参数是一个区间向量, 返回一个瞬时向量。它计算最新的 2 个样本值之间的差值。(当区间内仅有一个向量时无返回值)</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">deriv</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v range-vector) 的参数是一个区间向量,返回一个瞬时向量。它使用简单的线性回归计算区间向量 v 中各个时间序列的导数。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">exp</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 函数，输入一个瞬时向量，返回各个样本值的 e 的指数值，即 e 的 N 次方。</span><span style="font-family: 宋体, SimSun; font-size: 17px;">当得到一个无穷大的值，显示 +Inf， 反之显示0, e的负数次方无限趋进0。</span><span style="font-family: 宋体, SimSun; font-size: 17px;">e的空向量指数依然为空向量。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">year</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v=vector(time()) instant-vector) 函数返回被给定 UTC 时间的当前年份。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">hour</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v=vector(time()) instant-vector) 函数返回被给定 UTC 时间的当前第几个小时，时间范围：0~23。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">minute</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v=vector(time()) instant-vector) 函数返回给定 UTC 时间当前小时的第多少分钟。结果范围：0~59。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">month</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v=vector(time()) instant-vector) 函数返回给定 UTC 时间当前属于第几个月，结果范围：0~12。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">increase</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v range-vector) 函数获取区间向量中的第一个和最后一个样本并返回其增长量, 它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">rate</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v range-vector) 函数用于计算区间向量平均增长率，采用区间向量第一个值和最后值进行计算</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">irate</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v range-vector) 函数用于计算区间向量的增长率，但是其反应出的是瞬时增长率。irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">label_join</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...) 函数可以将时间序列 v 中多个标签 src_label 的值，通过 separator 作为连接符写入到一个新的标签 dst_label 中。可以有多个 src_label 标签。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">label_replace</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector, dst_label string, replacement string, src_label string, regex string) 在原标签中匹配字符，放到目标标签中</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">ln</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 计算瞬时向量 v 中所有样本数据的自然对数。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">log2</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 函数计算瞬时向量 v 中所有样本数据的二进制对数。特殊情况同ln。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">log10</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 计算瞬时向量 v 中所有样本数据的十进制对数。特殊情况同ln。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">predict_linear</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v range-vector, t scalar) 函数可以预测时间序列 v 在 t 秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">resets</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v range-vector) 的参数是一个区间向量。对于每个时间序列，它都返回一个计数器重置的次数。两个连续样本之间单调性发生变化被认为是一次计数器重置。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">round</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector, to_nearest=1 scalar) 函数与 ceil 和 floor 函数类似，返回向量中所有样本值的最接近to_nearest值整数倍的值，当to_nearest=1时等价于ceil。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">scalar</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 函数返回一个单元素瞬时向量的样本值，当多元素或者没有元素返回Nan。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">vector</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(s scalar) 函数将标量 s 作为没有标签的向量返回（和scalar作用刚好相反）。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">sort</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 函数对向量按元素的值进行升序排序。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">sort_desc</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 函数对向量按元素的值进行降序排序。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">sqrt</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 函数计算向量 v 中所有元素的平方根。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">timestamp</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(v instant-vector) 函数返回向量 v 中的每个样本的时间戳（从 1970-01-01 到现在的秒数）。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">avg_over_time</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(range-vector) : 区间向量内每个度量指标的平均值。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">min_over_time</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(range-vector) : 区间向量内每个度量指标的最小值。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">max_over_time</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(range-vector) : 区间向量内每个度量指标的最大值。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">sum_over_time</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(range-vector) : 区间向量内每个度量指标的求和。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">count_over_time</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">(range-vector) : 区间向量内每个度量指标的样本数据个数。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"><br/></span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">到此所有常用函数都介绍完了，还有一些少见的如直方图等请查阅prometheus官网文档。</span></p><p><br/></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/y9ks67szhj96\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    就如同SQL中有一些内置函数，PromQL中也存在一些函数，我们可以在进行PromQL表达式进行使用，完成一些数据的处理。聚合函数sum (求和)min (最小值)max (最大值)avg (平均值)\n                ');

INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (9, 'PromQL语法', 1, 2, '/media/blog/cover/prometheus.png', 1, '<p><span style="font-family: 宋体, SimSun; font-size: 17px;">Prometheus除了是一套监控系统，他有自身的同名时序数据库prometheus，类似于关系型数据库有自己的SQL，那么promQL就是prometheus的SQL</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">PromQL表达式或子表达式可以得到四种类型的值</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">瞬时向量</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">——一组样本值，所有样本值共享时间序列（时间戳相同）</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">区间向量</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">——一组一段时间范围类的样本值</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">标量</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">——一个固定的浮点数，-x.y 、n.m格式</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">字符串</span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">——一个字符类型的值，可以使用单引号、双引号、反引号包裹，遵循goalng语法的转义规则</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">可以使用大括号对向量进行筛选，得到我们需要的样本值，如：</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">其中大括号内的表达式支持完全匹配和正则匹配两种模式，括号内标签一共有这几种运算符：</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">=\xa0 </span><span style="font-family: 宋体, SimSun; font-size: 17px;">匹配相同字符串</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">!= </span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">匹配不相同字符串</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">=~ </span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">匹配正则表达式字符串</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">~! </span></strong><span style="font-family: 宋体, SimSun; font-size: 17px;">匹配正则表达式不相同字符串</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">正则表达式支持RE2语法，表达式必须至少包含一个指标名称或者一个不会匹配到空字符串的标签过滤器</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">除用户自定义标签外，每个指标还携带有一些内置的标签，如__name__即为指标名称</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">除了大括号以外，还可以使用中括号来筛选出一段时间范围内的样本值</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">时间窗口使用数字加单位组合表示，其中单位包括：</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">在查询中，我们默认都是以当前时间为基准去查寻瞬时或区间向量，但是有些场景我们需要查询过去某个时间点为基准的样本，就需要用到位移操作关键字 offset</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">除了以上描述的指标运算符之外，PromQL还支持算术类、比较类、逻辑类三类二元运算符，其中二元运算符特指瞬时向量，不包含区间向量</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（1）算术类</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">其中按照二元类型的不同，又可以分为以下几种运算结果：</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（2）比较类</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">比较类操作符有以下三组6条，表达式格式为：值1\xa0 运算符 bool 值二</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">按照二元类型不同，同样可将运算分为三类：</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">假设有这样一组瞬时向量，分别进行运算</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（3）逻辑类</span></strong></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">逻辑运算符必须在向量之间进行！</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（4）二元运算符优先级</span></strong></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">按照从高到底优先级排列为：算术 &gt; 比较 &gt; 逻辑， 算术中（乘方 &gt; 乘除模 &gt; 加减），比较全部同级，逻辑类（交差&gt;并）</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">向量的二元运算中均需要对向量元素进行匹配，匹配可以分为两种模式</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">两组向量里面标签键值对相同则为匹配，且匹配值只有一个。可以使用on关键字指定匹配标签或ingoring关键字忽略标签</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">相比于one-to-one需要使用组修饰符group_left或group_right指明匹配元素多的一侧，此种情况特别复杂，应当尽量少用，如果出现多匹配，则尽量使用ignoring关键字忽略对应标签。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">如上文我们使用到的sum()就是一种聚合函数，由于函数较多，此部分由下一篇文章单独讲解。</span></p><p><br/></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/21l7z2ard4tj\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    Prometheus除了是一套监控系统，他有自身的同名时序数据库prometheus，类似于关系型数据库有自己的SQL，那么promQL就是prometheus的SQL表达式值类型PromQL表达式或\n                ');

INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (10, '构建私有镜像仓库——Harbor', 1, 2, '/media/blog/cover/harbor.jpeg', 1, '<p><span style="font-family: 宋体, SimSun; font-size: 17px;">Harbor是一种使用go开发的私有镜像仓库服务，拥有部署简单、水平扩展、镜像同步、角色管理、镜像扫描、分层传输等优点，适合于企业内部构建自己的镜像仓库。以下介绍实际安装部署过程。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（1）硬件要求</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">实际搭建环境为8核CPU、62G内存、1.8T物理服务器</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（2）软件要求</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">打开浏览器，已经可以看到登录页面了，输入默认帐密admin/Harbor12345 可以查看到仓库信息。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">harbor支持从其他harbor平台通过pull方式将镜像同步到本地或者从本地push方式同步到其他平台。菜单选择复制管理，填写远端平台的超管帐密，完成后可选择手动触发或者定时任务同步。实测700GB镜像，第一次同步耗时13小时，后面同步速度压缩到4小时，最后将域名指向新平台，下班。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"><br/></span></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/ydtkt8fkq55x\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    Harbor是一种使用go开发的私有镜像仓库服务，拥有部署简单、水平扩展、镜像同步、角色管理、镜像扫描、分层传输等优点，适合于企业内部构建自己的镜像仓库。以下介绍实际安装部署过程。前置准备（1）硬件要\n                ');

INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (11, 'CPU性能——系统负载', 1, 2, '/media/blog/cover/CPU-cover.png', 1, '<p><span style="font-family: 宋体, SimSun; font-size: 17px;">平均负载指的是单位时间内，系统处于可运行状态和不可中断状态的平均进程数，即平均活跃进程数。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">正在使用cpu或者正在等待cpu的进程，我们可以通过ps查到的处于RUNNING或者Runnable状态的进程。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">处于内核态关键流程的进程，进程不可打断，如阻塞IO，我们可以在ps命令中查看到处于Uninterruptible Sleep 或 Disk Sleep状态的进程，这种进程是一种对硬件的保护机制。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">最为理想的平均负载为1，即一个cpu对应一个进程是操作系统最为理想的状态，此时系统负载低且cpu得到充分利用。</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">可以查看cpu个数，当平均负载大于cpu个数，则系统处于过载状态。通过最近1m、5m、15m的负载变化也可反映出系统负载的趋势。一般来说当cpu负载达到70%时就需要做排查对系进行统优化了。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">系统负载包含了正在使用、等待cpu、等待IO三部分的进程，而cpu使用率是针对正在使用cpu的进程，因此二者可能并不统一。<br/></span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（1）CPU密集型进程，此时二者一致，都会升高。</span></strong></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（2）I/O密集型进程，负载一定会升高，CPU使用率有可能空闲也有可能繁忙。</span></strong></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（3）大量等待CPU调度的进程，平均负载和CPU使用率都会高。</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">安装完成之后会得到stress、mpstat、pidstat三个命令工具，可用于实时查看CPU、内存、IO及上下文等性能指标。<br/></span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（1）CPU密集型进程模拟</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">可以观察到三个现象：A: 1m的系统负载逐渐升高。B: 有一个CPU使用率接近100%但是io等待接近0. C: 可以看到stress进程CPU使用率接近100%.</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（2）IO密集型进程模拟</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">可以观察到三个现象，A: 1m系统负载逐渐升高到1以上. B: 有一个CPU的使用率达到了35%, iowait升高到了50%。C: 可查看到stress进程cpu使用率高。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">（3）大量进程模拟</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">此处我们拥有4CPU，但是我们模拟了16进程的情况，可以观察到，A: 1m系统负载逐渐上升到4.x。 B: mpstat观察到所有CPU使用率升高到100%附近。 C: pidstat查看到大量stress进程系统负载高且等待高。</span></p><p><br/></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/hxxs0y6fluzn\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    平均负载平均负载指的是单位时间内，系统处于可运行状态和不可中断状态的平均进程数，即平均活跃进程数。jeeyshe@jeeyshe-PC:~$\xa0uptime\xa0\r\n\xa019:45:47\xa0up\xa012:19,\xa0\n                ');

INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (12, '真香！python静态类型注释', 1, 2, '/media/blog/cover/python-schema.png', 1, '<p><span style="font-family: 宋体, SimSun; font-size: 17px;">python是一门动态类型语言，变量无需定义类型，这在某些地方被称作python灵活的优点，但是随着业务的迭代，你会发现这种优点也许就是语言本身的缺点。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">比如这样一个函数，你这样写没有任何问题，IDE检查不出来任何错误，代码看起来简短优雅，但实际上你可能遇到过这些困扰：</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（1）你根本不知道user对象是否有create方法可以调用，你也不知道group对象是否有add方法可以给你调用，直到运行时解释器才会traceback。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（2）你在编写这段代码时，你打出一个user.然后table补全，编辑器没有办法联想出来能为你补全什么。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（3）当这个项目足够大、足够抽象时，你可能需要里三层外三层查看代码，最后终于能够确定user和group到底是什么类型。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">也许是很多开发者都遇到了这样的困扰，python团队终于在语言层面下手了，python3.6中引入了静态类型注解，虽然他只是注解并不能强制规定一个变量的类型，但是这已经足够解决以上三个问题了。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">以上代码定义了一个函数，他接收一个str类型的参数、一个int类型的参数、一个list类型的参数，返回一个str类型的值和一个tuple类型的值；此时我们在函数提使用变量.table进行自动补全时IDE已经可以联想出我们可能想调用的方法了，如果调用了一个不存在的方法则会进行warn提示，函数被调用时如果传递的参数或返回值和声明不对应也会进行warn提示。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">以上例子只进行了一个简单的类型注释，如果我们想要对list和tuple中子元素的类型做更进一步的声明，就需要引入类型注解住专用的包typing了。以下对常用的类型注解进行举例：</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（1）声明一个子元素为str类型的list参数（个数不限）</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（2）声明一个拥有2个子元素的tuple，且元素类型分别为int和str</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（3）声明一个key为str类型，value为float类型的dict</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（4）声明一个自定义类User类型的参数，返回值为任意字符串</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（5）声明一个任意类型参数（和不声名一样）</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（6）声明一个可选参数类型，类型可以是str或float或int</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（7）声明一个子元素类型为int，长度不限的tuple类型</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（8）声明一个可执行类型f，且f接收一个str类型和一个int类型参数，返回一个float类型的值</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（9）声明一个可执行类型f，f返回值为int类型，参数无要求</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（10）声明一个可变参数且设置默认值</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（11）为类型声明起一个别名（这在类型声明很长时、类型声明需要重复引用时非常好用）</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">（12）声明一个数据类型，类似于data_class装饰器</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">用过了静态类型注释之后，我只想说“真香！”。</span></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/r6brlot01v21\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    python是一门动态类型语言，变量无需定义类型，这在某些地方被称作python灵活的优点，但是随着业务的迭代，你会发现这种优点也许就是语言本身的缺点。为什么需要静态类型注释def\xa0run(user,\n                ');

INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (13, '云计算科普', 1, 2, '/media/blog/cover/cloud-cover.jpg', 1, '<p><span style="font-family: 宋体, SimSun; font-size: 17px;">云计算这个概念从提出到今天，已经差不多10年了。在这10年间，云计算取得了飞速的发展与翻天覆地的变化。现如今，云计算被视为计算机领域的一次革命，因为它的出现，社会的工作方式和商业模式也在发生巨大的改变。那么到底什么是云计算呢，你可能觉得他高端大气上档次，你可能觉得很神秘，本篇就以大白话，每个人都能看懂的方式给大家科普一下什么是云计算。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">要讲解云计算，那么就先讲一下计算。什么是计算呢，比如你需要记账、对账，你就要对一些数值进行加减乘除、开方、乘方等，像这样最基本的对于数值的一个简单运算就是计算。在古代我们运算的工具有绳结、算筹、算盘等，在现代我们平常使用的计算器都是这个用途。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">实际上计算不仅仅包含简单的数值运算，你可能听过逻辑运算（也叫布尔运算），或者比较复杂的矩阵运算（线性代数）、再或者是傅里叶变换这些更为复杂的运算，这些计算使用原有的计算工具是很难完成，因此就有了我们现代计算工具——计算机（computer），也就是我们俗称的电脑。对于个人电脑而言，你可以使用它听歌、看视频、画图、写文档、浏览网页，在这个过程中你感觉不到电脑在进行计算，例如听歌的本质：电脑读取一个很长的01组成的一串数字，然后控制扬声器按照对应的节奏震动，你就听到了歌声。总之，你在电脑上任意的行为都是通过01的计算实现的。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">知道了什么是计算，那云计算的概念就呼之欲出了。所谓云计算，狭义上就是指将计算放到网络上，通过网络技术为用户提供灵活扩展、按需分配的计算服务，简单理解这就是云计算。广义上讲，云计算是指提供计算服务梵高网络上背后一整套的技术手段，包括网络、存储、计算等部分。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">对于普通计算来讲，最大的问题在于成本，而云计算就是为了最大化的利用硬件资源、人力资源、以及实现灵活的扩容。比如说传统构建一个计算服务，你首先需要准备机房，机房需要配备空调、干燥设备、通风设备、气压等多项设施，需要和电信部门申请配置网络，需要成套的服务器、磁盘，存储服务、备份、容灾，有了这些硬件设置，你至少还需要招聘一帮技术人员组建一个运维团队、一个研发团队，这样才算是具备一个计算服务。而有了云计算之后，以阿里云为例，你需要做的就是好注册一个账号，购买服务，然后别人给你一个账号密码，你根本不知道真正的服务器和你相隔千山万水，也不需要关注硬件故障运维，通过账密即可开展你得业务开发、部署。现在通常将云计算分为IaaS、PaaS、SaaS三种，接下来将逐一介绍特点和典型应用。</span></p><p style="text-align:center"><span style="font-family: 宋体, SimSun; font-size: 17px;"><img src="/media/blog/img/cloud_20200721201929_393.jpg" title="" alt="cloud.jpg"/></span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">\xa0Infrastructure as a Service, 基础设施即服务。能够使消费者使用处理、储存、网络以及各种基础运算资源，部署与执行操作系统或应用程序等各种软件。这么看好像有点高大上，啥叫基础设施呢，打个比方，我们可以去阿里云购买一台ECS服务器（实际上就是一台虚拟机），然后后你就可以在操作系统里面安装各种软件、部署你自己的各种服务，像这样提供一个基础设施“操作系统”这样的服务就是典型的IaaS。还有如OpenStack、Zstack、CloudStack等虚拟化技术，都是属于典型的IaaS。</span></p><p style="text-align:center"><span style="font-family: 宋体, SimSun; font-size: 17px;"><img src="/media/blog/img/IaaS-ecs_20200721201948_624.png" title="" alt="IaaS-ecs.png"/></span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">Platform as a Service, 平台即服务。PaaS将软件研发的平台做为一种服务，以软件即服务（Software as a Service）模式交付给用户。因此，PaaS也是SaaS模式的一种应用。但是，PaaS的出现可以加快SaaS的发展，尤其是加快SaaS应用的开发速度（编者注：提供的软件服务 包括且不限于 操作系统、编程语言运行时、数据库）。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">用户不需要管理与控制云端基础设施（包含网络、服务器、操作系统或存储），但需要控制上层的应用程序部署与应用托管的环境。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"><span style="font-family: 宋体, SimSun; font-size: 17px;">此类的应用我们普通人接触不到，一般都是开发者使用的。此类应用通常需要我们在控制台注册一个application，然后通过账密直接调用服务和我们自身的业务进行对接，实现某些功能，按量或者按时付费。</span></span></p><p style="text-align:center"><span style="font-family: 宋体, SimSun; font-size: 17px;"><span style="font-family: 宋体, SimSun; font-size: 17px;"><img src="/media/blog/img/SaaS-baidu_20200721202118_679.png" title="" alt="SaaS-baidu.png"/></span></span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">Software as a Service，软件即服务。有时被作为“即需即用软件”（即“一经要求，即可使用”）提及。它是一种软件交付模式。在这种交付模式中云端集中式托管软件及其相关的数据，软件仅需透过互联网，而不须透过安装即可使用。用户通常使用精简客户端经由一个网页浏览器来访问软件即服务。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"><span style="font-family: 宋体, SimSun; font-size: 17px;">这种应用就很常见了，例如我们很多人都用过的有道笔记、processon、office365、xx笔记、xx协作，大都属于PaaS应用，我们无需关注需要什么操作系统、更不用关注需要什么硬件，我们通过打开一个网页或者一个客户端，就能马上使用像之前我们需要在自己电脑安装一个软件一样使用，完事后数据一键保存在云端，可随时打开阅读或者导出。</span></span></p><p style="text-align:center"><img src="/media/blog/img/PaaS-youdao_20200721202130_860.png" title="" alt="PaaS-youdao.png"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">1. IaaS 是云服务的最底层，主要提供一些基础计算资源。它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 IaaS。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">ZStack</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">OpenStack</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">CloudStack</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">Google Compute Engine</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">2. SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。普通用户接触到的互联网应用软件资源，几乎都是 SaaS，下面是一些例子。</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">同性交友服务 GitHub</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">团队协同服务 Teambition</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">储存服务 百度云盘 / One Drive / iCloud</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">社交服务 Facebook / Twitter / Instagram</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">视频服务 Youtube / BiliBili</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">3. PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。一个PaaS平台应该能够提供一个软件的所需平台性软件资源，例如：操作系统，Nginx，SQL数据库，NoSQL数据库，Java运行时等等。下面这些都属于 PaaS。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"><br/></span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">Cloud Foundry：业界第一个开源PaaS云平台，采用garden容器，对docker容器支持不好</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">Google App Engine：Google家的PaaS平台，对docker容器支持最好</span></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">OpenShift v3：RedHat家的PaaS平台</span></p><p><br/></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/69mk1g1r7lcy\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    云计算这个概念从提出到今天，已经差不多10年了。在这10年间，云计算取得了飞速的发展与翻天覆地的变化。现如今，云计算被视为计算机领域的一次革命，因为它的出现，社会的工作方式和商业模式也在发生巨大的改变\n                ');

INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (14, '网络设备科普', 1, 2, '/media/blog/cover/internet-cover.jpg', 1, '<p><span style="font-family:宋体, SimSun"><span style="font-size: 17px;">实际上我们在生活中wifi已经很普遍了，你可能经常听到交换机、路由器这样的字眼，你知道他是网络设备，但是你真的分得清他们都是做什么用的吗？这一篇就给大家科普一下常见的网络设备和作用。</span></span></p><p style="text-align:center"><span style="font-family: 宋体, SimSun; font-size: 17px;"><img src="/media/blog/img/network-line_20200712104742_919.png" title="" alt="network-line.png"/></span></p><p><br/></p><p data-key="5d5f9076b51f280001d5c703" class="p__1x2j"><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">最小的单元网络=网线+网卡+协议栈</span></strong></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f9077b51f280001d5c707" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">网线提供物理介质，承载电信号。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f9077e7228e0001053d42" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">网卡进行数据处理，将电脑存储设备里的数据和网线里的电信号互相转换。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f9078e7228e0001053d46" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">协议栈作为沟通语言，实现了通信过程中的数据解析、地址寻址、流控制等等。</span></p><p style="text-align:center"><span style="font-family: 宋体, SimSun; font-size: 17px;"><img src="/media/blog/img/network-line-not-ehough_20200712104944_327.png" title="" alt="network-line-not-ehough.png"/></span></p><p><br/></p><p data-key="5d5f9079b51f280001d5c713" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">如果两台终端之间距离太远，超过了网线物理传输距离上限，数据开始丢失。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f9079b51f280001d5c717" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">引入中继器。</span></p><p style="text-align:center"><img src="/media/blog/img/network-repeater_20200712105102_902.png" title="" alt="network-repeater.png"/></p><p><span style="font-family: 宋体, SimSun; white-space: pre; font-size: 17px;">中继器（Repeater）是一种物理层产品，能够对信息进行中继和放大，实现设备远距离传输。<br/></span></p><p style="text-align:center"><span style="font-family: 宋体, SimSun; font-size: 17px; white-space: pre;"><img src="/media/blog/img/network-hub_20200712105213_203.png" title="" alt="network-hub.png"/></span></p><p><br/></p><p data-key="5d5f9079b51f280001d5c723" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">中继器一般只有两个接口，意味着网络中只能存在两台终端。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f9079e7228e0001053d54" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">引入集线器。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907ae7228e0001053d56" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">集线器（Hub）是“多口中继器”，也是物理层的产品，能够对信息进行中继和放大，任意接口收到的数据，会王其他所有接口泛洪。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907ae7228e0001053d58" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">集线器不识别数据包的寻址信息和上层内容，无法对终端进行隔离，所有终端处于同一个冲突域，采用集线器的网络，带宽利用率较低。</span></p><p style="text-align:center"><img src="/media/blog/img/network-bridge_20200712105336_117.png" title="" alt="network-bridge.png"/></p><p><br/></p><p data-key="5d5f907be7228e0001053d60" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">网桥（Bridge）是一种链路层产品，能够链路层产品，能够记录终端主机的MAC地址并生成MAC表（也成为CAM表），MAC表相当于“地图”，网桥根据MAC表转发主机之间的数据流</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907be7228e0001053d62" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">网桥能够对冲突域进行隔离，有效提高带宽利用率，不同接口之间的数据不会互相冲突。例如PC1发给PC2的数据不会转发到右边（E2）口。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907cb51f280001d5c72f" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">网桥的接口比较有限，默认是两个接口，对网络的冲突隔离作用有限。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907cb51f280001d5c731" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">网桥没有专门的硬件而是通过CPU来处理数据，速度不够快。</span></p><p style="text-align:center"><img src="/media/blog/img/network-switch_20200712105508_766.png" title="" alt="network-switch.png"/></p><p><br/></p><p data-key="5d5f92ea4445cf0001bb5e98" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">交换机（Switch）是一种链路层产品，能够记录终端主机的MAC地址并生成MAC表（CAM表）。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907cb51f280001d5c739" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">交换机是在网桥的基础上进行延伸和升级，相比网桥，主要有以下几个优势：</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907ce7228e0001053d72" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">- 接口数量更多（每个终端在独立的冲突域，带宽利用率大大提高）</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907cb51f280001d5c73b" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">- 采用专门的ASIC硬件芯片进行高速转发</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907ce7228e0001053d74" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">- 能够进行VLAN隔离（不仅仅可以隔离冲突域，还能通过VLAN隔离广播域）</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907ce7228e0001053d76" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">交换机是一种局域网产品，一般用于本地网络，无法实现广域网通信。</span></p><p style="text-align:center"><span style="font-family: 宋体, SimSun; font-size: 17px;"><img src="/media/blog/img/network-router_20200712105643_610.png" title="" alt="network-router.png"/></span></p><p><br/></p><p data-key="5d5f907cb51f280001d5c745" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">路由器（Router）是一种网络层产品，基于IP协议寻址，采用路由表实现数据转发</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907cb51f280001d5c747" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">路由器主要用于连接不同局域网（可以是不同介质的局域网，如令牌网可以和以太网互通）。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907cb51f280001d5c749" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">路由器诞生是互联网大爆发的主要原因，跨介质跨地理的网络融合成为现实。</span></p><p><span style="top: -94px; font-family: 宋体, SimSun; font-size: 17px;"/></p><p data-key="5d5f907cb51f280001d5c74b" class="p__1x2j"><span style="font-family: 宋体, SimSun; font-size: 17px;">IP协议等逻辑寻址是实现不同类型局域网联通的关键，不同局域网的主机只要配置了IP地址，有合理的网段规划，就可以通信；路由器在实现局域网之间通信时，会进行“介质翻转”和“路由转发”。</span></p><p data-key="5d5f907cb51f280001d5c74b" class="p__1x2j"><span data-key="3fbb9b30-c3e8-11ea-8605-2b4fc0a37afc-143"><br/></span></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/x0era7dofp7o\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    实际上我们在生活中wifi已经很普遍了，你可能经常听到交换机、路由器这样的字眼，你知道他是网络设备，但是你真的分得清他们都是做什么用的吗？这一篇就给大家科普一下常见的网络设备和作用。如何连接两台电脑主\n                ');

INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (15, '基于注释的接口文档工具apidoc', 1, 2, '/media/lujianxin.com.png', 1, '<p><span style="font-family: 宋体, SimSun; font-size: 17px;">apidoc是一种基于代码注释自动生成api文档的工具，支持python、java、js、perl等多种语言，使用还是比较简单的。</span></p><p style="text-align:center"><img src="/media/blog/img/apidoc_20200710184827_945.png" title="" alt="apidoc.png" width="980" height="524" style="width: 980px; height: 524px;"/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">apidoc需要一份配置文件来确定生成文档的格式等信息</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">此方式需要将方式一中apidoc.json内容放到一个叫做apidoc的字段中</span><br/></p><p><br/></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/jc533sub1tbe\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    apidoc是一种基于代码注释自动生成api文档的工具，支持python、java、js、perl等多种语言，使用还是比较简单的。安装工具包sudo\xa0apt\xa0install\xa0-y\xa0npm\r\nsudo\xa0\n                ');

INSERT INTO blog (id,title,author_id,cat_id,cover,music_id,content,source,is_fine,is_top,"read",'like',"add",'mod',is_active,digest) VALUES (16, 'Linux软连接和硬链接', 1, 2, '/media/blog/cover/linux-cover.jpg', 1, '<p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">一切皆文件</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">Linux系统中，一切都是文件，为了区分文件呢，我们通常又将文件分为几种类型：<br/></span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">- 普通文件<br/></span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">- 目录文件</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">- 链接文件</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">- 设备文件</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">其中普通文件如上图的.txt、.log、.gz等等，当然普通文件也可以没有后缀名，后缀名只是方便肉眼识别文件类型的作用（比如你完全可以将一个文本文件命名为xxx.mp3）。目录文件如上图Baidu文件夹，可以看到他的文件类型是d。链接文件如ping，我将它连接到了/usr/bin/ping 命令，他的文件类型是l。设备文件如我们的/dev下的设备（磁盘），分区等。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">文件描述符</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">上一篇<a href="https://www.lujianxin.com/x/art/ogqjbet7znn9" target="_blank">Linux文件系统工作原理</a>中我们介绍了inode索引节点，inode和所有文件一一对应，记录文件的元数据和位置。文件描述符（file descriptor）则是内核为了高效管理被打开的文件，为文件创建的索引，他本质是一个小正整数（通常是1024以内）。所有I/O操作都通过这个文件描述符来进行系统调用，例如我们可以使用python打开一个文件然后查看他的文件描述符：</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">此处顺便说一下三个特殊的文件描述符：</span><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;"/></p><p><br/></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">腾讯云服务器会跑一个云盾服务，查看他的定时任务你可以看到：</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">此处 2&gt;&amp;1 的写法意思就是将标准错误重定向到输出，注意此处如果写的是 2 &gt; 1 则是将标准错误重定向到一个名为1的文件，&amp;1才是重定向到标准输出。</span></p><p><strong><span style="font-family: 宋体, SimSun; font-size: 17px;">软链接和硬链接</span></strong></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">我们经常为操作系统建立软链接，最为常见的是为一些命令创建软链接到/usr/bin或者/usr/local/bin下面。</span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">可以对<span style="font-family: 宋体, SimSun; color: rgb(34, 34, 34); background-color: rgb(255, 255, 255);">任意文件或目录创建他的多个软链接，可以链接不同文件系统的文件，在对符号文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身，这一点类似于 Windows 操作系统下的快捷方式。</span></span></p><p><span style="font-family: 宋体, SimSun; font-size: 17px;">硬链接则是通过inode建立的链接，不同的硬链接都会指向同一个索引节点，即指向同一块文件区域。我们可以手动尝试建立一下软链接和硬链接。</span><br/></p><p><span style="color: rgb(34, 34, 34); background-color: rgb(255, 255, 255); font-family: 宋体, SimSun; font-size: 17px;">硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件,以防止“误删”的功能，只有当所有硬链接被删除后，文件的数据块及目录的连接才会被释放。</span></p><p><span style="color: rgb(34, 34, 34); font-family: &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; background-color: rgb(255, 255, 255);"/></p><p><span style="color: rgb(34, 34, 34); font-family: &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; background-color: rgb(255, 255, 255);"/><br/></p>\n\n        \n        <p class="con_info">\n            \n                <b>版权声明</b>\n                本文属于本站<b>\xa0\xa0原创</b>作品，文章版权归本站及作者所有，请尊重作者的创作成果，转载、引用自觉附上本文永久地址：\n                https://www.lujianxin.com/x/art/3vltpzcv4mhl\n            \n        </p>\n        \n        ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-08-20 19:43:47', '2020-08-20 19:43:47.320327', 1, '\n                    一切皆文件Linux系统中，一切都是文件，为了区分文件呢，我们通常又将文件分为几种类型：- 普通文件- 目录文件- 链接文件- 设备文件jeeyshe@jeeyshe-PC:~/Downloads$\xa0\n                ');
(15, ['APP 中的 JS 加密逆向解析'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/CPU-cover.png'], 1, '<p>APP 加载 JS 的逆向解析方法</p>\n<p><strong>抓取登录包</strong></p>\n<p>解决安全检测</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress5-1601444181.png" alt="APP 中的 JS 加密逆向解析1"/></p>\n<p>\xa0</p>\n<p>使用木木模拟器，安装好app刚准备愉快的抓个包。竟然检测到root，不能进入。那就先把这个给他hook掉。</p>\n<p>用jadx打开apk，全局搜索一下，提示的文字。</p>\n<p>\xa0</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1601444181.png" alt="APP 中的 JS 加密逆向解析2"/></p>\n<p>\xa0</p>\n<p>可以看到这里进行了几种检测，编写frida hook代码，直接把 initCheckSafe 方法置空</p>\n<p>\xa0</p>\n<p>解决完毕，我们再进入app</p>\n<p>\xa0</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444181.png" alt="APP 中的 JS 加密逆向解析3"/></p>\n<p>又提示要跟新，事是真的多。那就更新吧。点击更新后，加载了一些东西，然后进入了登录页面。（!!! 后面发现这里的坑）</p>\n<p>\xa0</p>\n<p><strong>抓包分析</strong></p>\n<p>\xa0</p>\n<p>配置好代理，直接抓包。<br/>\n可以看到请求的数据模式都是<br/>\naction=xxxx&amp;data=json</p>\n<p>\xa0</p>\n<p><img class="rich_pages js_insertlocalimg" title="APP 中的 JS 加密逆向解析4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1601444181-1.png" alt="APP 中的 JS 加密逆向解析4"/></p>\n<p>\xa0</p>\n<p>把这个json数据拿出来看看，多尝试几次发现密码不变这个password不变，其他的参数都可以写死。到这里，如果账号少的话，手动抓一次包后续使用就可以了。但是咱能满足于此吗，盘它！</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444182.png" alt="APP 中的 JS 加密逆向解析5" width="219.07072pt" height="453.6pt"/></p>\n<p>\xa0</p>\n<p><strong>寻找加密位置</strong></p>\n<p><strong>盲狙碰运气</strong></p>\n<p>这个参数看着像是，某种加密后base64的结果。先base64解码看看啥情况。将加密后的值urldecode之 \xa0 \xa0后再base64解码</p>\n<p><img title="APP 中的 JS 加密逆向解析6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444182.png" alt="APP 中的 JS 加密逆向解析6" width="443.29172pt" height="273.6pt"/></p>\n<p>\xa0</p>\n<p>一堆乱码看不懂。那我们使用南山大佬写的xposed的模块把常见加密hook一波，尝试快速定位。激活xposed plus模块，然后打开ddms，查看日志信息。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444182.jpeg" alt="APP 中的 JS 加密逆向解析7" width="432.9008pt" height="200.02496pt"/></p>\n<p><img title="APP 中的 JS 加密逆向解析8" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress6-1601444182.jpeg" alt="APP 中的 JS 加密逆向解析8" width="447.6163pt" height="203.80496pt"/></p>\n<p>\xa0</p>\n<p>可以看到常见的加密类都被hook到了，但是在保存的日志中尝试搜索输入的密码，抓包的加密结果等， 都一无所获。</p>\n<p>\xa0</p>\n<p><strong>搜索反编译代码</strong></p>\n<p>\xa0</p>\n<p>看来好事多磨，快的不行那我们去分析代码吧。</p>\n<p>尝试搜索 登录链接 登录参数字段值等，都寻找不到有用的信息，事情好像陷入了僵局。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析9" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444183.png" alt="APP 中的 JS 加密逆向解析9" width="441.38245pt" height="337.1775pt"/></p>\n<p>\xa0</p>\n<p><strong>巧计寻出路</strong></p>\n<p>\xa0</p>\n<p>静静思考一会，回想到登录接口参数data后面的值是一个json类型，也就是字典类型。那能不能hook java中这个类，看看有没有password赋值的操作</p>\n<p>百度一波，得到如下hook代码</p>\n<p>\xa0</p>\n<p>把这代码灵活运用一下，我们再登录一次看看结果。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析10" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444183.png" alt="APP 中的 JS 加密逆向解析10" width="444.48254pt" height="236.85748pt"/></p>\n<p>\xa0</p>\n<p>果然发现了赋值操作，那就过滤一下无用的信息，再把这个操作的调用栈打印出来，顺藤摸瓜，那不就 \xa0能找到加密位置了嘛。感觉看到了希望。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析11" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444183-1.png" alt="APP 中的 JS 加密逆向解析12" width="406.83118pt" height="291.45pt"/></p>\n<p>\xa0</p>\n<p>还好调用栈不是很多，去掉 java开头的和proxy，剩下的我们从上面开始一个个看一下，有没有加密的地方。</p>\n<p>一直找到最下面这个方法,参数可以看到是从 exec 这个函数的参数传来的。那么hook这个exec的入参看一下。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析13" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析13" width="445.2466pt" height="290.7pt"/></p>\n<p>\xa0</p>\n<p>hook 结果：</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析14" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress7-1601444184.png" alt="APP 中的 JS 加密逆向解析14" width="444.75pt" height="54.75pt"/></p>\n<p>\xa0</p>\n<p>这下蒙蔽了，都追到根了，咋还是加密过的值呢。</p>\n<p>\xa0</p>\n<p><strong>再肯硬骨头</strong></p>\n<p><strong>发现线索一</strong></p>\n<p>有困难但是也不能放弃。再自己端详一下exec的代码，发现它头部有个@JavascriptInterface好像装饰 器一样的东西，和别的函数都不一样。<br/>\n不懂咱就去搜索一下，然后发现这个是可以让 js 和 java 互相调用的一个东西。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析15" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析15" width="443.7912pt" height="76.259926pt"/></p>\n<p>\xa0</p>\n<p>那就知道方向了，加密是在js中进行的，然后js中调用java里的exec方法，将值传了进来。</p>\n<p>将apk反编译，先去找找那些js中，有cbPassInfo setOfflineCache这些信息。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析16" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析16" width="444.78873pt" height="172.51495pt"/></p>\n<p>\xa0</p>\n<p>哟呵，搜到了这两个里面有。把他俩拖出来瞅一瞅。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析17" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444184.jpeg" alt="APP 中的 JS 加密逆向解析17" width="443.59882pt" height="127.170006pt"/></p>\n<p>\xa0</p>\n<p>在 login.js 里面只有这两处。先验证一下这里是不是传加密值的地方。</p>\n<p>我把这里的 cbPassInfo 改成别的字符串，然后重新打包签名apk，安装，再抓取一次登录包，如果出现的是我修改的字符，那说明这就是调用的位置。</p>\n<p>信心满满，又抓了一次包。结果啪啪打脸。还是 cbPassInfo 。</p>\n<p>\xa0</p>\n<p><strong>发现线索二</strong></p>\n<p>突然想到，重新安装打开后，有个提示框，更新资源，难道它又重新下载了这个文件，把我修改的重置 \xa0了。</p>\n<p>卸载，重装后，抓包查看下它更新的资源，发现果然是这样。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析18" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184.png" alt="APP 中的 JS 加密逆向解析18" width="447.34598pt" height="175.77pt"/></p>\n<p>\xa0</p>\n<p>既然修改apk不行，js又是静态文件，那直接在模拟器中搜索login.js<br/>\n结果有3，4个，把文件重命名，app打开没了登录界面，那就是它了。</p>\n<p>\xa0</p>\n<p><strong>模拟加密</strong></p>\n<p><strong>分析js</strong></p>\n<p>先分析一下js，密码就是通过蓝框两个方法加密的。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析19" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444184-1.jpeg" alt="APP 中的 JS 加密逆向解析19" width="445.2799pt" height="176.46pt"/></p>\n<p>\xa0</p>\n<p>先搜索一下 D 和 Base64，Base64没有获得有效的信息。发现D应该和 sha1 有关系</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析20" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1601444185.jpeg" alt="APP 中的 JS 加密逆向解析20" width="443.6568pt" height="133.91992pt"/></p>\n<p>\xa0</p>\n<p>这里js不好调试，我们利用js调用java的流程，把我们想要的值传给java层，然后去hook接收的函数。这 \xa0 \xa0 \xa0里把我把用到的函数，各种结果都打印了一下。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析21" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1601444185.png" alt="APP 中的 JS 加密逆向解析21" width="444.0pt" height="134.25pt"/></p>\n<p><img title="APP 中的 JS 加密逆向解析22" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1601444185.jpeg" alt="APP 中的 JS 加密逆向解析22" width="449.93283pt" height="96.36pt"/></p>\n<p>\xa0</p>\n<p>这个D刚才看是和sha1相关的，用标准的sha1对比一下。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析23" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444185.png" alt="APP 中的 JS 加密逆向解析23" width="443.68427pt" height="162.36pt"/></p>\n<p>发现和上面结果相同。那就只剩base64这个函数了。看打印出来的代码，发现这不是一个标准的base64，运行报错缺少 c 变量。</p>\n<p>搜素函数内的代码，在common.js中发现了</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析24" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress9-1601444185-1.png" alt="APP 中的 JS 加密逆向解析24" width="443.46616pt" height="72.54pt"/></p>\n<p>\xa0</p>\n<p>现在逻辑清楚了，把c的值拿过来，用js来实现加密。可以看到结果和抓包一致，收工。</p>\n<p>\xa0</p>\n<p><img title="APP 中的 JS 加密逆向解析25" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1601444185.jpeg" alt="APP 中的 JS 加密逆向解析25" width="444.00867pt" height="179.7pt"/></p>\n<p>\xa0</p>\n<p><strong>总结</strong></p>\n<p>之前遇到的app都是在java代码中加密，或者 so库里面。在js中的这是第一次遇到。</p>\n<p>幸运的是js没有做处理，如果把web端的反扒应用在这，手机端又不好对js进行调试，那真是够秃头的了，可怕。</p>\n<p>这篇来自小伙伴 ID: 浮生 的投稿。</p>\n<p>安利下偶的爬虫逆向进阶课，包含 安卓逆向抓取/安卓群控/JS逆向抓取/爬虫框架设计与工程经验，国庆时正好学习下，目前熟悉安卓逆向抓取技术拿个20K+ 的 offer 还是容易。</p>\n<p><strong>具体点击下面连接</strong></p>\n<p><a href="https://www.yuanrenxue.com/crawler/crawler-course.html" target="_blank" rel="noopener">我出了一套爬虫高阶学习课</a></p>\n<p>\xa0</p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'APP 加载 JS 的逆向解析方法抓取登录包解决安全检测\xa0使用木木模拟器，安装好app刚准备愉快的抓个包。竟然检测到root，不...');
(16, ['安卓逆向之Luac解密反编译'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/prometheus.png'], 1, '<p>本文阐述针对Cocos2dx-lua提供的轻量级加密方案的反编译。</p>\n<p>本文demo对象：</p>\n<p><img title="安卓逆向之Luac解密反编译1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress1-1600222829.png" alt="安卓逆向之Luac解密反编译1"/></p>\n<p>lua文件大概分3种。lua是明文代码，直接用ide能打开，luac是lua编译后的字节码，文件头特征为0x1B 0x4C 0x75 0x61 0x51。</p>\n<p>lua虚拟机直接解析lua和luac脚本文件，luaJIT是另一个lua的实现版本，采用即时解析运行机制，luaJIT更高效，文件头特征为0x1B 0x4C 0x4A。</p>\n<p><strong>加密流程</strong></p>\n<p>一篇文章搞定Cocos2dx-lua正向开发打包流程：</p>\n<p>CSDN文章【Cocos2dx-lua 3.11.1】打包lua项目为安卓apk</p>\n<p>https://blog.csdn.net/lannan91/article/details/67637373/</p>\n<p>加密指令：cocos luacompile -s 未加密源码目录 -d 加密后源码目录 -e -k 加密key -b 加密sign –disable-compile<br/>\n“</p>\n<p><strong>解密逻辑</strong></p>\n<p>lua官方加解密实现方式很容易就能查找资料得到，根据得到key和sign就可以利用xxtea算法来对脚本进行解密，只需要三个条件，文件路径&amp;加密sign&amp;加密key就能解密。<br/>\n加密和解密算法在这：<br/>\nhttps://github.com/cocos2d/cocos2d-x-3rd-party-libs-bin/tree/v3/xxtea</p>\n<p><strong>实现过程</strong></p>\n<p>加密sign的找寻方法sign在.luac文件头中<br/>\n随机打开一个项目内的.luac文件，找第一个字符串。</p>\n<p><img title="安卓逆向之Luac解密反编译2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress5-1600222829.jpeg" alt="安卓逆向之Luac解密反编译2"/></p>\n<p>\xa0</p>\n<p><strong>加密key的找寻方法</strong></p>\n<p>key在打包后的cocos的lib库的libcocos2dlua.so中<br/>\n1.第一种方法是libcocos2dlua.so使用IDA pro打开，全局查找加密sign。点击进入查找结果，在该结果的上方3行能够发现加密key。<br/>\n2.第二种方法，由于写作的电脑已经升级到10.15.5 (19F101)，IDA pro运行有问题。所以用osx自带的strings工具查找。<br/>\n2-1.终端运行\xa0strings -a libcocos2dlua.so<br/>\n2-2.ctrl+f 查找sign，观察sign上方的字符串，即为key。</p>\n<p><img title="安卓逆向之Luac解密反编译3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress0-1600222829.png" alt="安卓逆向之Luac解密反编译3"/></p>\n<p><strong>解密实现</strong></p>\n<p>OSX实现脚本：<br/>\nhttps://github.com/dengxiaochun/luac_decodeToolwin实现工具：<br/>\nhttps://www.jb51.net/softs/575428.htmlOSX演示：<br/>\n将解密脚本放在项目assets目录下</p>\n<p><img title="安卓逆向之Luac解密反编译4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress8-1600222830.png" alt="安卓逆向之Luac解密反编译4"/></p>\n<p>修改decode.sh的SIGN&amp;KEY变量，并保存。</p>\n<p><img title="安卓逆向之Luac解密反编译5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress1-1600222831.png" alt="安卓逆向之Luac解密反编译5"/></p>\n<p>终端执行：sh ./decode.sh src</p>\n<p><img title="安卓逆向之Luac解密反编译6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress2-1600222831.png" alt="安卓逆向之Luac解密反编译6"/></p>\n<p>执行结果：</p>\n<p><img title="安卓逆向之Luac解密反编译7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress4-1600222832.png" alt="安卓逆向之Luac解密反编译7"/></p>\n<p>\xa0</p>\n<p>执行后脚本将自动备份luac源代码（src_backup）</p>\n<p><img title="安卓逆向之Luac解密反编译8" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress3-1600222833.png" alt="安卓逆向之Luac解密反编译8"/></p>\n<p>解密后的.lua文件在src目录中，ide打开，源代码反编译成功，可以进一步研究程序的客户端源码实现。</p>\n<p><img title="安卓逆向之Luac解密反编译9" src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/beepress10-1600222834.png" alt="安卓逆向之Luac解密反编译9"/></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本文阐述针对Cocos2dx-lua提供的轻量级加密方案的反编译。本文demo对象：lua文件大概分3种。lua是明文代码，直接用ide能打开，lu...');
(17, ['巧破某报价大全APP加密参数-iOS逆向抓取'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/CPU-cover.png'], 1, '<p>iOS作为一种闭源系统，没有Android那么多的packers和so库，iOS官方封装了自己统一的Crypto库，所以我们HOOK起来也很方便。我以某报价大全 iOS v10.5.5版为例，记录一下巧破加密参数的过程和一些知识点。</p>\n<p>此次逆向教程使用到的工具如下：</p>\n<p>一部越狱iPhone或iPad</p>\n<p>抓包工具：Charles</p>\n<p>Hook 框架：frida v12.8.11</p>\n<p>通过Charles抓取目标APP列表页请求的数据，我们发现含有32位的“sign”参数，且向下滑动加载更多时“sign”参数都会变化。两次抓包请求参数对比如下图：</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress3-1591693046.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数1"/></p>\n<p>通过对比抓包数据，我们猜测可能使用了MD5加密算法，接下来我们就用frida-trace监控iOS系统封装的CC_MD5加密函数，看能不能巧破该APP的“sign”参数。</p>\n<p>首先通过 frida-ps -Ua （请自行安装frida）查看目标APP的进程id为4934：<br/>\n<img title="iOS逆向抓取-巧破某报价大全APP加密参数2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591693046.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数2"/></p>\n<p>\xa0</p>\n<p>再通过frida-trace跟踪“CC_MD5”函数，命令如下：</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress9-1591693046.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数3"/></p>\n<p>\xa0</p>\n<p>frida-trace参数说明如下：</p>\n<p>-U\xa0\xa0 \xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 使用USB数据线连接设备</p>\n<p>-i\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0\xa0\xa0 \xa0追踪函数</p>\n<p>“CC_MD5” \xa0 \xa0要追踪的函数名</p>\n<p>4934 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0目标APP进程id</p>\n<p>接着在终端界面按 Ctrl+C 停止运行。然后在__handlers__/ASEProcessing文件夹中找到CC_MD5.js文件，将代码修改为如下并保存：</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress6-1591693046.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数4"/></p>\n<p>\xa0</p>\n<p>以上代码会在追踪到CC_MD5函数步入时打印待加密的参数值，步出时打印加密后的md5返回值。<br/>\n接着我们继续使用之前的命令运行frida-trace，然后在目标APP列表页继续滑动即可看到frida-trace追踪到的参数和返回值。然后我们用Charles抓包看到的sign值到frida-trace窗口中搜索即可找到对应参数，如下图：</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress0-1591693047.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数5"/></p>\n<p>对比请求的url和加密参数：<br/>\n-请求的url：api.ashx?cateid=3&amp;cityid=&amp;method=news.list&amp;pageindex=3&amp;pagesize=25&amp;productid=7&amp;serialid=&amp;sign=fbe1c8222424f38371f0b59592a6293b-加密的参数：?cateid=3&amp;cityid=&amp;method=news.list&amp;pageindex=3&amp;pagesize=25&amp;productid=7&amp;serialid=2CB3147B-D93C-964B-47AE-EEE448C84E3C</p>\n<p>请求url中标注部分与加密参数标注部分完全一致，我们可以确定盐值为：2CB3147B-D93C-964B-47AE-EEE448C84E3C。至此“sign”参数md5加密算法不攻自破了。</p>\n<p><img title="iOS逆向抓取-巧破某报价大全APP加密参数6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591693047.png" alt="iOS逆向抓取-巧破某报价大全APP加密参数6"/></p>\n<p>\xa0</p>\n<p>本文重点在通过Charles抓包看到“sign”参数为32位字符串，猜测是md5加密，从而使用frida-trace监控目标APP是否使用了iOS系统封装的CC_MD5加密函数。之后一击即中巧破了“sign”参数加密算法。</p>\n<p>对于我们爬虫工作者在抓取数据时遇到加密“sign”参数，首先可以猜测其大致的算法，之后用frida-trace去监测系统默认的加密函数，比如iOS系统的：CC_MD5，CC_SHA1，CCHmac等，有可能会有意想不到的收获。如果此方法行不通，我们可以再去想办法逆向分析。</p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'iOS作为一种闭源系统，没有Android那么多的packers和so库，iOS官方封装了自己统一的Crypto库，所以我们HOOK起来也很方便。我以某报...');
(18, ['APP爬虫-某APP iOS版逆向过程'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/harbor.jpeg'], 1, '<p>本篇来自周小鱼同学的投稿，跟着猿人学王平大佬学了一段时间安卓APP逆向，刚刚入门。由于我使用Mac和iOS更频繁，所以我以某汽车 iOS 版为例，记录一下逆向过程和一些知识点。</p>\n<p><strong>此次逆向教程使用到的工具如下：</strong></p>\n<p>一部越狱iPhone或iPad<br/>\n抓包工具：Charles<br/>\n反编译分析工具：IDA64_v7.0<br/>\nHook 框架：objection v1.9.1<br/>\nhttps://github.com/sensepost/objection<br/>\n调试工具：LLDB，Debugserver</p>\n<p>抓包发现含有32位数的“_r”参数(可能为MD5加密)以及34位数的sign参数，且每次请求都会变化。经过反复抓包对比测试，发现无论修改任何参数再提交服务器都会返回url签名错误，并且发现sign参数最后2位数不变，猜测是32位数MD5密文加字符串“01”组成。接下来的重点就是分析“sign”和“_r”是怎么生成的。</p>\n<p>两次抓包参数文本对比效果图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress6-1591691472.png" alt="APP爬虫-某APP iOS版逆向过程1"/></p>\n<p>使用 frida-iOS-dump 一键砸壳后，将砸壳后的二进制文件拖入到IDA中进行分析。由于“sign”关键字可能存在太多干扰不利于分析，所以我们从一个可能干扰比较少的关键字“ttDna” 开始分析。</p>\n<p>在IDA strings 窗口搜索ttDna，有且只有一个结果完全吻合，如下图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress0-1591691472.png" alt="APP爬虫-某APP iOS版逆向过程2"/></p>\n<p>通过这个关键字，我们进入到了函数：-[CBDBaseApi extraParams]，果断使用 objection（如何使用请自行查阅资料） 对此函数进行hook，查看其参数、返回值和调用堆栈，截图如下：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress8-1591691473.png" alt="APP爬虫-某APP iOS版逆向过程3"/></p>\n<p>返回值确实包含了我们抓包中看到的信息，但是不完整，需要继续追踪调用函数。</p>\n<p>通过第一个堆栈地址 0xc4ed40 + IDA64头部偏移量 0x100000000 =\xa00x100c4ed40 找到IDA64中相应地址调用的地方，发现在函数：-[MCCBaseApi buildFullUrl:] 内部。我们继续使用 objection 对此函数进行 hook，发现返回值与我们抓包看到的完全吻合：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress4-1591691473.png" alt="APP爬虫-某APP iOS版逆向过程4"/></p>\n<p>从上面返回值的截图可以看出完整的url是由此函数拼装而成，接下来我们在IDA64中按F5键查看该函数的伪代码，逆向由下往上分析：<br/>\nreturn=v21=v20=v14=v13，<br/>\n发现返回值是<br/>\n+[MCCURLManager buildUrlString:withParams:sign:]<br/>\n生成的：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591691473.png" alt="APP爬虫-某APP iOS版逆向过程5"/></p>\n<p>继续追踪<br/>\n-[MCCURLManager buildUrlString:withParams:sign:] ，</p>\n<p>发现来自于<br/>\n-[MCCURLManager buildUrlString:withParams:sign:useBasicParam:usePublicParam:]。<br/>\n在此函数中，我们发现了“_r”参数。</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress9-1591691473.png" alt="APP爬虫-某APP iOS版逆向过程6"/></p>\n<p>经过分析“_r”参数是随机生成的UUID经过MD5加密得到。</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress0-1591691474.png" alt="APP爬虫-某APP iOS版逆向过程7"/></p>\n<p>继续一路追踪sign参数，发现到了一个跟sign有关的函数：+[MCCSignURLManager signUrl1:withKey:]，果断使用 objection hook该函数，参数和返回值仅仅只多了一串sign参数，由此可以判断sign在此函数内生成，并且发现key值是：<br/>\nSW+SaqSibZdCmqNyh4WYlW+l，<br/>\n截图如下：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程8" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress9-1591691474.png" alt="APP爬虫-某APP iOS版逆向过程8"/></p>\n<p>继续分析该函数的伪代码，我们看到一个自定义的函数 SignUrl1，如下图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程9" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress3-1591691474.png" alt="APP爬虫-某APP iOS版逆向过程9"/></p>\n<p>双击进入SignUrl1，我们又看到另一个自义定函数 SignUrl0，如下图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程10" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress10-1591691474.png" alt="APP爬虫-某APP iOS版逆向过程10"/></p>\n<p>双击进入SignUrl0，我们看到熟悉的MD5加密算法，如下图：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程11" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress8-1591691475.png" alt="APP爬虫-某APP iOS版逆向过程11"/></p>\n<p>逆向分析到此，我们可以大胆猜测，SignUrl1是在组装加密参数，之后将参数传递给 SignUrl0 进行MD5加密之后再将密文返回给SignUrl1。</p>\n<p>现在我们只需要查看SignUrl0函数的具体参数就可以知道如何加密了。接下来我们使用LLDB+debugserver（具体如何使用请自行查阅资料）在图下位置下断点并查看传入的具体参数：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程12" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress10-1591691475.png" alt="APP爬虫-某APP iOS版逆向过程12"/></p>\n<p>参数1为不包含sign参数部分的请求内容，部分截图如下：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程13" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress5-1591691475.png" alt="APP爬虫-某APP iOS版逆向过程13"/></p>\n<p>参数2为key值经过base64decode等步骤转换而来的固定字符串：<br/>\n5oBjPRiG2ZSbwqDAoQ，<br/>\n也就是MD5加密的盐。这里我们无需深究key是如何转换的，只需拿到key的固定字符串即可：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程14" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress6-1591691475.png" alt="APP爬虫-某APP iOS版逆向过程14"/></p>\n<p>所以sign参数算法就是由函数SignUrl0的入参1+入参2经MD5加密后与“01”拼接得到。接下来我们验证一下我们猜测的算法与抓包是否一致：</p>\n<p><img title="APP爬虫-某APP iOS版逆向过程15" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress1-1591691476.png" alt="APP爬虫-某APP iOS版逆向过程15"/></p>\n<p><img title="APP爬虫-某APP iOS版逆向过程16" src="https://www.yuanrenxue.com/wp-content/uploads/2020/06/beepress3-1591691476.png" alt="APP爬虫-某APP iOS版逆向过程16"/></p>\n<p>由上面2张图可以看出sign参数算法完全正确，至此sign参数和“_r”参数全部告破。接下来就可以使用Python实现算法然后自由爬取文章了。</p>\n<p>本篇文章的案例用到了Charles抓包，frida-iOS-dump砸壳，IDA64反编译，objection HOOK框架，以及LLDB+debugserver调试等工具。每一个工具的使用都需要花大量时间研究，本文并未对以上工具的使用进行详细说明，感兴趣的同学可以自行查阅相关资料。</p>\n<p>案例中的APP也算是大厂开发的，而我们对其二进制文件的加密函数分析并不是太难，没有对关键字加密，没有复杂的算法，也没有对函数名进行混淆，直接使用IDA64进行静态分析，以及使用objection hook查看参数和返回值就追踪到了加密的函数。</p>\n<p>所以做爬虫工作碰到APP逆向这个事情，首先不要害怕，其实市场上大多数APP的加密参数都可以通过我们这种方式搞定。当然很难的也有很多，比如关键字加密，函数名混淆，反调试检测，多线程循环发包，网络发包封装第三方库等等，面对这些只要有信心有耐心，多学习实操总结，慢慢积累经验，会有所成的，大家共勉！</p>\n<p><strong>PS：广而告之：</strong><br/>\n把猿人学·爬虫高阶课又更新了，加入了安卓群控，详情点击<a href="https://www.yuanrenxue.com/crawler/advance-course.html">https://www.yuanrenxue.com/crawler/advance-course.html</a></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本篇来自周小鱼同学的投稿，跟着猿人学王平大佬学了一段时间安卓APP逆向，刚刚入门。由于我使用Mac和iOS更频繁，所以我以某汽车 iOS...');
(19, ['分析app的登陆协议'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/UTF-8.png'], 1, '<p>这是一篇逆向分析APP登陆流程的文章。</p>\n<p>（1） 抓包前将手机和电脑连接到同一WIFI，在手机设置好代理，装好证书，就可以开始抓包了。之前我遇到抓不到包的情况，换了几个代理工具也不行，最后是开着热点抓到包（一台开热点，另一台和电脑连接热点），或者换成手机抓包工具HttpCanary等也可以抓包。</p>\n<p>（2） 抓包环境配置好后，在登陆界面随便填一个账号密码：</p>\n<p><img title="分析app的登陆协议1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585810.png" alt="分析app的登陆协议1" width="264.0pt" height="159.65pt"/></p>\n<p>（3） 点击登录，查看Fiddler中的数据包数据包中的参数：city=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;citycode=010&amp;device=63ac32df-d1c2-3008-828e-ef9f1bb3a96d&amp;device_model=google%20Pixel%202&amp;device_name=google%20Pixel%202&amp;device_os=Android%205.1.1&amp;device_product=google&amp;device_size=1080*1920&amp;device_type=1&amp;district=%E4%B8%9C%E5%9F%8E%E5%8C%BA&amp;fake_id=37979341&amp;interface_code=620&amp;latitude=39.91640353732639&amp;longitude=116.41024359809028&amp;mobile=13426355456&amp;password=EBEDF39355506FF1F42AAD7A20E1DB83&amp;province=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;province_code=1582770774000&amp;version=6.2.0&amp;securitykey=41de91b2c71d0af71c7a71887e14b57d</p>\n<p>一般需要抓两次包来对比数据包参数的变化，观察哪些参数是固定或者容易得到的，哪些是不能直观看出需要进一步分析：</p>\n<p><img title="分析app的登陆协议2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress5-1590585810.png" alt="分析app的登陆协议2" width="415.25pt" height="120.35pt"/></p>\n<p>对比两个数据包可以看到，手机号没有加密，密码做了加密，还有一个参数securitykey也是加密的。这次逆向的重点也就是分析这两个参数的生成逻辑。</p>\n<p>（1） 直接把apk用jadx反编译，发现做了加固，是legu的壳，相关逻辑代码没法直接看到：</p>\n<p><img class="rich_pages" title="分析app的登陆协议3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress10-1590585811.png" alt="分析app的登陆协议3"/></p>\n<p>（2） 这里我使用了一个基于frida编写的脱壳工具：https://github.com/hluwa/FRIDA-DEXDump\xa0原理是在内存中暴力搜索，根据dex文件的结构特征将其dump下来，启动frida-server，启动app，运行脚本就可以了。如果使用过程中报错，可以试试重启手机，或者杀死app进程并重启app。</p>\n<p>（1）之前抓到的包是分析的入口点，在jadx中反编译dump下来的dex，点击菜单栏的小魔法棒搜索securitykey这个参数：</p>\n<p><img title="分析app的登陆协议4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585811.png" alt="分析app的登陆协议4" width="415.3pt" height="41.85pt"/></p>\n<p>结果如下;第四个GLOBAL_PARAMS_KEY = “securitykey”比较显眼，双击打开看看，也可以把右边所有结果挨个点开分析：</p>\n<p><img class="rich_pages" title="分析app的登陆协议5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585811.png" alt="分析app的登陆协议5"/></p>\n<p>\xa0</p>\n<p>观察代码，securitykey参数应该是在其他位置被引用，右键GLOBAL_PARAMS_KEY，选择查找用例，看看哪些地方用了这个参数：</p>\n<p><img title="分析app的登陆协议6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress8-1590585811.png" alt="分析app的登陆协议6" width="415.25pt" height="161.05pt"/></p>\n<p>根据经验推测，第二个stringBuffer.append一般是数据包参数构造的位置，双击打开它：</p>\n<p><img class="rich_pages" title="分析app的登陆协议7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress8-1590585812.png" alt="分析app的登陆协议7"/></p>\n<p>GLOBAL_PARAMS_KEY的值就是securitykey参数，接着拼接了一个“=”和一个finalSecStr的变量</p>\n<p><img title="分析app的登陆协议8" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585812.png" alt="分析app的登陆协议8" width="415.2pt" height="110.8pt"/></p>\n<p>双击这个finalSecStr变量，可以看到finalSecStr在代码中的处理逻辑，可以看到是经过getMD5Str这个方法处理得到的，看函数名感觉是计算MD5：</p>\n<p><img title="分析app的登陆协议9" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1590585812.png" alt="分析app的登陆协议9" width="415.2pt" height="181.6pt"/></p>\n<p>\xa0</p>\n<p>继续看getMD5Str的参数secStr，发现是由this.paramMap处理得到：</p>\n<p><img title="分析app的登陆协议10" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585812.png" alt="分析app的登陆协议10" width="415.15pt" height="138.1pt"/></p>\n<p>再往上分析，发现this.paramMap中值就是数据包那些参数：</p>\n<p><img title="分析app的登陆协议11" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1590585813.png" alt="分析app的登陆协议11" width="415.05pt" height="199.45pt"/></p>\n<p>自此，securitykey这个参数的计算逻辑差不多出来了，把this.paramMap中的参数挨个拼接“|”变成secStr，再传给getMD5Str，返回的值就是数据包中securitykey的值。<br/>\n按住Ctrl键，单击getMD5Str这个方法，可以看到就是MD5的计算：</p>\n<p><img title="分析app的登陆协议12" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress2-1590585813.png" alt="分析app的登陆协议12" width="415.2pt" height="239.15pt"/></p>\n<p>点击菜单栏中的向左小箭头返回上一层代码：</p>\n<p><img title="分析app的登陆协议13" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress8-1590585813.png" alt="分析app的登陆协议13" width="372.0pt" height="36.6pt"/></p>\n<p>我们可以通过hook getMD5Str方法，将其参数和返回值打印出来，验证我们的分析。这里涉及到一个问题，这个app加了壳，直接去hook会出现“ClassNotFoundError“的错误，这是因为getMD5Str这个方法不是一开始就在内存中的，它是被壳加载起来的。所以hook方法要有所改变。</p>\n<p>原理：所有的类都是通过ClassLoader的loadClass方法加载的，于是可以等我们要hook的这个方法所在的类被加载后再去hook，这样就可以百发百中了，多个DEX的情况下也可以使用这个方法该方法出处：https://bbs.pediy.com/thread-225190.htm</p>\n<p><img title="分析app的登陆协议14" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585813.png" alt="分析app的登陆协议14" width="465.05pt" height="294.5pt"/></p>\n<p>Hook getMD5Str方法后打印参数和返回值，编译安装xposed插件，重启手机，结果发现什么也没hook到，确认类名和方法名，参数都没问题。经过长时间的分析也没结论，最后是用ddms发现了问题：jadx反编译得到的类名，方法名不正确，与真实命名不一样。<br/>\n%1. ddms的使用ddms是一个AndroidSDK自带的方法追踪工具（一般位于SDK的tools目录下），用于记录app执行过的方法。这里我们需要记录的是点击登陆按钮后app执行的方法。打开ddms后，先选中app对应的进程，然后选择菜单栏中的“开始追踪”</p>\n<p><img class="rich_pages" title="分析app的登陆协议15" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585814.png" alt="分析app的登陆协议15"/></p>\n<p>\xa0</p>\n<p>选择第二个，记录所有方法</p>\n<p><img title="分析app的登陆协议16" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1590585814.png" alt="分析app的登陆协议16" width="381.0pt" height="207.6pt"/></p>\n<p>接着以最快的手速点击登录按钮（因为ddms会记录系统中在运行的很多进程的方法），等到弹出“该账号不存在”（因为我们随便输入的），立即点击ddms的“停止追踪”按键（跟“开始追踪”是同一个，不过现在变灰了），就能得到从点击登陆按钮后到账号校验完期间app执行的所有方法：</p>\n<p><img title="分析app的登陆协议17" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585814.png" alt="分析app的登陆协议17" width="414.95pt" height="66.55pt"/><br/>\n接着会弹出一个trace文件，就是记录下来的方法：<br/>\n<img title="分析app的登陆协议18" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress2-1590585814.png" alt="分析app的登陆协议18" width="414.9pt" height="148.2pt"/></p>\n<p>在最下面find搜索栏中输入app的包名，按回车键挨个观察记录下来的方法，在其中找到了getMD5Str方法的正确类路径，而之前在jadx中反编译得到的是：com.XXXXXX.common.utils.encrtption.MD5Helper.getMD5Str所以用jadx中的类路径肯定是hook不到getMD5Str方法了。</p>\n<p><img class="rich_pages" title="分析app的登陆协议19" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585815.png" alt="分析app的登陆协议19"/></p>\n<p>\xa0</p>\n<p>把类路径改成ddms记录的正确路径，重新编译hook插件，重启手机，运行app，输入账号密码，点击登录，在ddms的日志中可以发现，这次顺利的打印出了getMD5Str方法的参数和返回值：</p>\n<p><img title="分析app的登陆协议20" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress1-1590585815.png" alt="分析app的登陆协议20" width="509.05pt" height="157.5pt"/></p>\n<p>对比数据包参数：</p>\n<p><img title="分析app的登陆协议21" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585815-1.png" alt="分析app的登陆协议21" width="414.9pt" height="118.95pt"/></p>\n<p>将getMD5Str方法的参数与数据包中参数对比，发现是一致的，返回值就是参数的MD5值，验证了我们之前的分析是对的：</p>\n<p><img title="分析app的登陆协议22" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585815.png" alt="分析app的登陆协议22" width="370.8pt" height="181.85pt"/></p>\n<p>%1. password参数的分析分析完了securitykey这个参数，现在就分析password这个参数，可以发现，并没有在大量参数构造的地方发现password：</p>\n<p><img title="分析app的登陆协议23" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1590585816.png" alt="分析app的登陆协议23" width="415.05pt" height="199.45pt"/></p>\n<p>在jadx中搜索也没有发现：</p>\n<p><img class="rich_pages" title="分析app的登陆协议24" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress1-1590585816.png" alt="分析app的登陆协议24"/></p>\n<p>\xa0</p>\n<p>观察上面的参数，他们都是带着双引号的，尝试给password加上双引号搜索，终于看到了：</p>\n<p><img title="分析app的登陆协议25" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress10-1590585816.png" alt="分析app的登陆协议25" width="444.05pt" height="91.45pt"/></p>\n<p>第二个看着像是AES加密有关的，双击进去看看，果然是：</p>\n<p><img title="分析app的登陆协议26" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585816.png" alt="分析app的登陆协议26" width="510.5pt" height="79.65pt"/></p>\n<p>按住Ctrl，点开AesEncryptionHelper看看，是”AES/CBC/PKCS5Padding”的加密方法：</p>\n<p><img title="分析app的登陆协议27" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress9-1590585816.png" alt="分析app的登陆协议27" width="415.0pt" height="62.4pt"/></p>\n<p>验证一下：</p>\n<p><img title="分析app的登陆协议28" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress6-1590585817.png" alt="分析app的登陆协议28" width="490.75pt" height="204.6pt"/></p>\n<p>跟数据包中的password的值是一样的：</p>\n<p><img title="分析app的登陆协议29" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1590585817.png" alt="分析app的登陆协议29" width="415.2pt" height="53.2pt"/></p>\n<p>自此，两个加密参数的分析就完成了。</p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '这是一篇逆向分析APP登陆流程的文章。1. 抓包（1） 抓包前将手机和电脑连接到同一WIFI，在手机设置好代理，装好证书，就可以开始...');
(20, ['正式把猿人学爬虫高阶课放在网课平台了'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/cloud-cover.jpg'], 1, '<p><img class="rich_pages" title="正式把爬虫高阶课放在网课平台了" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1589809617.jpeg" alt="正式把爬虫高阶课放在网课平台了"/><br/>\n我跟 virjar 出了一套爬虫课（猿人学·爬虫高阶培训课），包含：安卓逆向抓取、JS 高阶逆向抓取、安卓群控抓取、容器定制化等。</p>\n<p>实际上我去年就在做这个爬虫课了，一直没有放到网课平台上公开宣传，但是也已有100多位同学信任我，跟着我在精进爬虫技术。</p>\n<p>今年 virjar 大佬加入，我俩一起做这个爬虫课，目标是做一套成体系和有竞争力的爬虫高阶课。</p>\n<p>\xa0</p>\n<p><strong>| 课程内容 |</strong></p>\n<p>爬虫技术进阶体现在反爬对抗和规模化抓取上。</p>\n<p>目前网页的对抗难度上限是跟浏览器特征绑定的高度混淆 JS 和验证码拖拽等；APP 的加固，SO 混淆，抓包和风控特征检测等。</p>\n<p>这套爬虫课程内容涉及反混淆极具难度的 JS 和拖拽验证码；以及 APP 的 HOOK 抓取，安卓容器虚拟化技术做设备指纹对抗和安卓群控抓取技术。</p>\n<p>课程还包含爬虫工程化经验，诸如规模化抓取优化窍门，社会工程，还有我们实战经验总结的一点点黑科技。</p>\n<p>\xa0</p>\n<p><strong>| 额外内容 |</strong></p>\n<p>在上述课程之外，猿人学·爬虫高阶课内容还额外做有爬虫简历写作技巧，面试和利用爬虫技术挣被动收入的实践经验和方法论。</p>\n<p>大部分简历写作上都不合格，如何写一份合格的爬虫简历，增加面试邀约机率是一个技巧。</p>\n<p>还包含我过去几年利用爬虫技术结构化数据整合做流量挣钱的实践经验和实践方法论。</p>\n<p>\xa0</p>\n<p><strong>| 获得的权益 |</strong></p>\n<p>进入猿人学内部学习群</p>\n<p>提供远程模拟面试辅导</p>\n<p>提供爬虫技术问题指导</p>\n<p>优先提供爬虫外包项目</p>\n<p>现在内部群已有100多个同学，分布在数十个城市，我们希望做成一个互帮互助的学习组织，在群里相互交流指导技术，找工作，职场等问题。</p>\n<p>我自己还会提供面试指导，以后工作中的技术问题我也提供指导。</p>\n<p>\xa0</p>\n<p><strong>| 课程提纲 |</strong></p>\n<p><img src="https://www.yuanrenxue.com/wp-content/uploads/2020/09/crawler-course.jpg" alt="猿人学爬虫进阶课提纲"/></p>\n<p><strong>| 课程形式 |</strong></p>\n<p>视频录播，一共50节，每节平均90分钟，目前已更新40节。</p>\n<p>视频是动态更新的，有过期的内容或有更好的技术方案，就会重新制作对应视频。</p>\n<p>\xa0</p>\n<p><strong>| 适合人群 |</strong></p>\n<p>有爬虫基础，想找爬虫工作或已有爬虫工作，想技术再进阶的同学。</p>\n<p>感兴趣的同学可以扫下面二维码，购买。</p>\n<p>也可以点击此连接，进入有赞购买</p>\n<p><a href="https://detail.youzan.com/show/goods?alias=2okabph85ypv1&amp;activity_alias=undefined">https://detail.youzan.com/show/goods?alias=2okabph85ypv1&amp;activity_alias=undefined</a></p>\n<p><img class="rich_pages js_insertlocalimg" title="正式把爬虫高阶课放在网课平台了" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress9-1589809618.jpeg" alt="正式把爬虫高阶课放在网课平台了"/></p>\n<p>你也可以扫码进入详情页，注册成为分销员，把该课程分销出去，每成一单有200多元的现金奖励。</p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '我跟 virjar 出了一套爬虫课（猿人学·爬虫高阶培训课），包含：安卓逆向抓取、JS 高阶逆向抓取、安卓群控抓取、容器定制化等。实...');
(21, ['某文APP逆向抓取分析'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/UTF-8.png'], 1, '<p>本篇来自跟我精进爬虫技术的同学（包子xia）投稿，文章的条理逻辑和对逆向工具使用，分析思路都很熟练。有苏州或南京的老板看上的，可以联系我噢，有潜力的爬虫工程师一枚。</p>\n<p>在学习了一段时间的爬虫逆向后，正好有需求要采集某某文书的一些数据，因此就以此app为例，给大家介绍一下如何使用frida找加密代码的思路，从而实现自动化采集。特此说明，本文仅供学习交流，请勿用作其他用途。</p>\n<p><strong>主要使用的工具和环境如下：</strong><br/>\n设备：一部root的手机或者手机模拟器（本人使用nexus6p真机）;<br/>\n抓包工具：fiddler；<br/>\n分析工具：jadx-gui 1.1.0；<br/>\n脱壳工具：xposed+fdex2；<br/>\n执行代码: pycharm + python3.6；<br/>\nhook框架：frida；</p>\n<p><strong>抓包初步分析</strong></p>\n<p>首先手机与电脑连在同一个网络，设置好代理和端口，打开fiddler，运行手机app，我们随意搜索某个关键词查看下抓包结果：</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress4-1588914079.png" alt="某文APP逆向抓取分析"/></p>\n<p>从上图我们可以看出他是发出一个post请求，data是一个以request=开头的一长串加密字符，返回值是由两部分组成，一个serectkey，一个content。我们再输入一个不同的关键词，抓包得到结果与这次结果进行对比。</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914079.png" alt="某文APP逆向抓取分析"/></p>\n<p>由于参数不是很多，就不借用对比差异工具了。对比两张图，我们可以很明显得到以下几点信息：<br/>\n1.请求的url不发生改变；<br/>\n2.headers这部分没有加密；<br/>\n3.post请求的data部分是改变的，全是由字母和数字组成，初步观察有点像base64；<br/>\n4.返回值部分 初步猜测 content是由serectkey钥匙解密得到，可能是aes、des等等加密；<br/>\n由上面初步分析，我们就有方向去找加密的代码。主要寻找的就是request=后面那部分到底是什么东西，返回值是由什么加密而成的。</p>\n<p><strong>请求参数java代码分析</strong></p>\n<p>我们使用xposed+fdex2进行脱壳，得到dex源码（这边就不演示过程了），发现只有一个dex，看来app还是挺轻量级的。</p>\n<p>小tips：因为这边只有一个dex文件，所以源代码肯定在内。如果有多个dex文件的话，建议先从文件最大的那个开始排查，这样会节省点时间。<br/>\n使用jadx打开dex文件，点击导航-&gt;搜索文本。从上文分析来看，我们该搜索request这个关键词，看看能不能返回一些结果。</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress3-1588914079.png" alt="某文APP逆向抓取分析"/></p>\n<p>发现搜索结果又200多个，要么一个个去排查，实在是太浪费时间，要么换个搜索方式。其实经常查看源码的小伙伴，可能会对变量赋值这一块搜索比较有经验，通常这种字符串，都会以以下几种方式去搜索：<br/>\n“request”<br/>\n“request”:<br/>\n“request”,<br/>\n使用上面的全文搜索，我们可以很快定义到代码赋值的地方，</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1588914079.png" alt="某文APP逆向抓取分析"/></p>\n<p>我们点击进去查看，发现调用了com.lawyee下面的b方法，传进去的参数是str.getBytes()，因此我们首先想知道传进去的值是什么，发现上文在g.b这一块调用了了str，经过查看可知，g.b就是一个log函数，输出日志用的，我们通过firda hook这一块方法，可以查看str是什么。hook代码如下</p>\n<p><code>Java.perform(function(){</code><br/>\n<code>varAndroidLog=Java.use("android.util.Log")</code><br/>\n<code>varAndroidException=Java.use("java.lang.Exception")</code><br/>\n<code>function printStackTrace(){</code><br/>\n<code>        console.log(AndroidLog.getStackTraceString(AndroidException.$new()));</code><br/>\n<code>}</code><br/>\n<code>varMainActivity=Java.use(\'com.lawyee.***.util.g\');</code><br/>\n<code>MainActivity.b.overload(\'java.lang.String\',\'java.lang.String\').implementation =function(params1,params2){</code><br/>\n<code>        send("Hook Start...")</code><br/>\n<code>//send("stack"+printStackTrace())</code><br/>\n<code>        send("params1:"+params1)</code><br/>\n<code>        send("params2:"+params2)</code><br/>\n<code>var result =this.b(params1,params2)</code><br/>\n<code>        send("result"+result)</code><br/>\n<code>}</code><br/>\n<code>});</code><br/>\n<img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914079-1.png" alt="某文APP逆向抓取分析"/></p>\n<p>其实从这边我们就可以看出，str就是request加密前的明文。经过多次输入不同关键词，可以得知一下几个关键信息：<br/>\nid 是变化的，经观察和时间有关；<br/>\ncommand = 固定参数；<br/>\npageNum = 页数；<br/>\npageSize = 一页显示的数量<br/>\nsortFields = “s50:desc” 固定参数；<br/>\nciphertext = 变化的，需要找到其加密方式；<br/>\npageSize = 每页的个数，可自行构造；<br/>\ndevid = 猜想是设备id，不发生改变；<br/>\nqueryCondition = [{“key”:”s21”,”value”:”小米”}] # 关键词 + 搜索文本的类型；<br/>\n下面我们就需要构造这些参数，组成完整的请求data，主要是两个参数ciphertext 以及id，又开始我们的全局搜索大法，发现在这里对ciphertext和id赋值。</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress10-1588914080.png" alt="某文APP逆向抓取分析"/><br/>\n<img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1588914080.png" alt="某文APP逆向抓取分析"/></p>\n<p>ciphertext = d.a();<br/>\nid 相当于是当前年月日小时分钟和秒组合而成，可构造;<br/>\n我们进入d.a()，发现代码有点长，这一块我们使用frida.rpc去调用，写一个web服务，每次请求的使用调用一次这个方法。<br/>\n<code>rpc.exports ={</code><br/>\n<code>    getsig:function(){</code><br/>\n<code>var ciphertext ="";</code><br/>\n<code>Java.perform(function(){</code><br/>\n<code>            send("here")</code><br/>\n<code>varMainActivity=Java.use(\'com.lawyee.****.util.d\');</code><br/>\n<code>            ciphertext =MainActivity.a()</code><br/>\n<code>})</code><br/>\n<code>return ciphertext</code><br/>\n<code>}</code><br/>\n<code>};</code></p>\n<p>走到这一步，我们已经可以实现自动化构造参数，下面就是要找到如何加密得到request，从文章开始我们猜测使用的base64。机智的我就把加密后的request经过base64.decode() 发现和我们构造的参数一模一样，这样就可以实现请求获取数据了。还有一种方法就是去也是用rpc调用c.a().b方法，实现获取post data。这边我选择直接使用base64。</p>\n<p><code>req_url =\'http://127.0.0.1:5001/getsigs?data={}\'.format("11")# 请求web服务获取ciphertext</code><br/>\n<code>response = requests.get(req_url)# ciphertext</code><br/>\n<code>id = time.strftime("%Y%m%d%H%M%S")</code><br/>\n<code>pagenum =1</code><br/>\n<code>pageSize =20#</code><br/>\n<code>keyword ="小米"# 关键词</code><br/>\n<code>ori_data ={"id":"%s"% id,"command":"queryDoc","params":{"pageNum":"%s"% str(pagenum),"sortFields":"s50:desc","ciphertext":"%s"% get_cipher(),"devtype":"1","devid":"5b1a4e4ffdf54c4996b00b6f57ae14f9","pageSize":"%s"% str(pageSize),"queryCondition":[{"key":"s21","value":"%s"% keyword}]}}</code><br/>\n<code>bytes_data = json.dumps(ori_data).encode("utf-8")# 二进制</code><br/>\n<code>str_data = base64.b64encode(bytes_data)# 被编码的参数必须是二进制数据</code><br/>\n<code>data ="request="+str_data.decode()# 加密后的参数</code></p>\n<p>由此我们就用python实现了的请求，得到加密前的数据。</p>\n<p><strong>返回结果加密解析</strong></p>\n<p>哈哈哈，又开始我们的猜测大法，所有加密全靠猜。一个key，一个加密后的content，让人浮想联翩。一般开发app不会自己去写一个加密算法，那样太浪费时间并且消耗成本了。其实百度搜索java常用的加密算法，我们就可以大概猜出来答案，后面无非就是一个一个去全局搜索。我们首先排除base64、MD5，这些不需要key值，常用到key值的就是des和aes这两种了，在java中，调用这两类算法需要使用调用这两个类，我们投机取巧全局搜索了一下发现了新大陆!!!</p>\n<p><code>import javax.crypto.Cipher;</code><br/>\n<code>import javax.crypto.SecretKey;</code><br/>\n<img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914080.png" alt="某文APP逆向抓取分析"/></p>\n<p>上图中，m.a(str,str1,str2)是des3加密函数，m.b是解密函数，大概看下这一部分的代码，只需要知道iv是偏移量，使用上面第一个a方法返回而来（yyyyMMdd年月日），key就是请求返回的值，content也是，我们使用frida hook一下</p>\n<p><code>Java.perform(function(){</code><br/>\n<code>varMainActivity=Java.use(\'com.lawyee.***.util.m\');</code><br/>\n<code>MainActivity.b.overload(\'java.lang.String\',\'java.lang.String\',\'java.lang.String\').implementation =function(params1,params2,params3){</code><br/>\n<code>        send("Hook Start... here7")</code><br/>\n<code>        send("params1:"+params1)</code><br/>\n<code>        send("params2:"+params2)</code><br/>\n<code>        send("params3:"+params3)</code><br/>\n<code>var result =this.b(params1,params2,params3)</code><br/>\n<code>        send("result:"+result)</code><br/>\n<code>return result</code><br/>\n<code>}</code><br/>\n<code>});</code><br/>\n<img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress0-1588914080-1.png" alt="某文APP逆向抓取分析"/></p>\n<p>params1 就是请求返回的content<br/>\nparams2 是key<br/>\nparams3 是iv(偏移量)<br/>\nresult 是的des3解密后的结果<br/>\n到此为止，所有的加密都已经找出来啦，本来准备把des3这段代码考出来的用java执行，不过想起来之前对该网页端网站写爬虫的时候，用python实现了des3加密，今天也算用上了。</p>\n<p><code>fromCryptodome.Cipherimport DES3</code><br/>\n<code>fromCryptodome.Util.Paddingimport unpad</code><br/>\n<code>def des3decrypt(cipher_text, key, iv):</code><br/>\n<code>    des3 = DES3.new(key=key.encode(), mode=DES3.MODE_CBC, iv=iv.encode())</code><br/>\n<code>    decrypted_data = des3.decrypt(base64.b64decode(cipher_text))</code><br/>\n<code>    plain_text = unpad(decrypted_data, DES3.block_size).decode()</code><br/>\n<code>return plain_text</code><br/>\n<code><br/>\n</code></p>\n<p>这样子就可以完整的构造请求了并且获得数据了，我们尝试请求了一下，获得的结果如下：</p>\n<p><img title="某文APP逆向抓取分析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/05/beepress7-1588914080-1.png" alt="某文APP逆向抓取分析"/></p>\n<p>感兴趣的童鞋可以自己去尝试一下，整体不是很难哦。</p>\n<p><strong>总结</strong></p>\n<p>这个app从刚拿到手到解密结束，没有什么特别的坑，比较适合新手去练练手。主要的就是找到自己hook代码的思路以及找加密方法的一些小技巧。此app还没有涉及到so层面上的调用，难度下降了不少。</p>\n<p>总结起来就是如果平常逆向app的时候遇到加密参数比较多的，不要慌张，一步一步去找到加密地址的所在，合理的利用frida hook技巧，靠打印参数能够得到不少有效信息。逆向app一定要多练习，这样才能在实践中找到自己的不懂之处，才能够成长。好啦，今天的逆向小文章就到此结束啦，童鞋们下篇文章再见咯。</p>\n<p>PS：<br/>\n我出了一套爬虫高阶课程，包含：安卓/JS 逆向抓取，大规模爬虫框架设计和爬虫工程经验。感兴趣的点击这下面链接：</p>\n<p><a href="https://www.yuanrenxue.com/crawler/crawler-course.html" target="_blank" rel="noopener">我出了一套爬虫高阶学习课</a></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本篇来自跟我精进爬虫技术的同学（包子xia）投稿，文章的条理逻辑和对逆向工具使用，分析思路都很熟练。有苏州或南京的老板看上的，...');
(22, ['Android 7.0 Https抓包单双向验证解决方案汇总'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/harbor.jpeg'], 1, '<p>这篇是跟我精进爬虫技术的小伙伴的实操总结文投稿，一篇标准的安卓7抓包指南。</p>\n<p>因为App对设备限制的原因，换了一台 Android 7 的测试机，在这期间又遇上了几种棘手的检测与验证。感觉采用防抓包技术的厂商越发多了起来。解决完这些问题，写一篇日志来记录一下，作为日后排查手册。</p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总1" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress3-1586442650.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总1"/></p>\n<p>Android 7.0 之后，默认情况下 app 只信任系统级别的 CA 。从 chls.pro/ssl 安装的证书是在用户级，这导致了 Charles 无法拦截应用流量。有两种方法可以绕过：</p>\n<p>（一）将 Charles CA 安装为系统级 CA ，需要修改 /system 权限，全局 APP 生效，需 Root</p>\n<p>（二）修改 APP 包 Androidmanifest 文件并重打包，仅针对单一APP生效，无需 root</p>\n<p>\xa0</p>\n<p><strong>第一种操作，基于 ADB shell 安装证书，需要 Root ：</strong></p>\n<p>\xa0</p>\n<p><strong>第二种操作，基于修改 Manifest 重新打包 APK，免Root :</strong></p>\n<p>原理是当 platformBuildVersionCode&gt;=24 时候，App 就只信任系统级别的CA。修改 apk 中的AndroidManifest 强行降底运行环境的 API Level ，虽然麻烦，但这种方案的存在意义是，目标APP 有设备 Root 检测时适用。</p>\n<p>运行 Apktool 反解，Android Studio 打开 AndroidManifest.xml ，目标 API 级别会在文件的 “manifest” 元素的 “platformBuildVersionCode” 属性中指定。将 platformBuildVersionCode=26改成 23 ，使用 apktool 重新打包签名安装，就可以正常抓包了。</p>\n<p>流程：<br/>\napktool反解<br/>\n修改AndroidManifest.xml<br/>\napktool 打包<br/>\nkeytool 生成证书<br/>\njarsigner apk签名<br/>\n如果有签名校验，jadx分析修改smali绕过<br/>\n<img title="Android 7.0 Https抓包单双向验证解决方案汇总2" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress2-1586442650.jpeg" alt="Android 7.0 Https抓包单双向验证解决方案汇总2"/></p>\n<p>（一）App单向验证APP 内置校验证书，即厂商将证书文件或证书值内置在 APK 安装包内，通信请求时 app 自身通过代码来校验证书和服务器的关系，即 SSL Pinning 。有2种解决方案：</p>\n<p>1.逆向 App 取出证书，导入到抓包程序中</p>\n<p>证书通常在 /assets 里<br/>\njadx 反编译后搜索 .p12 .pem .cer ssl 等关键词<br/>\nHook 监听证书读取位置<br/>\n——-实例暂略，有空另起一篇专门写扣证书——-</p>\n<p>\xa0</p>\n<p>2. Hook 绕过证书的校验逻辑</p>\n<p>JustTrustMe（Root+Xposed）<br/>\nDroidSSLUnpinning(Root/免Root+Frida)</p>\n<p>JustTrustMe 在测试过程中并不顺利，首先安装时需要依赖 Xposed 框架，如果目标采用xposed 检测，会引发新的问题。并且 JustTrustMe 在某些 App 的新版本已失效，只能分析旧版本 app 或等待作者更新。用法简单，安装后 xposed 勾选启动，重启手机。</p>\n<p>DroidSSLUnpinning 在 Root 和非 Root 环境下都可以工作，Root 环境下操作更方便一些：<br/>\n确认本地环境已安装 frida&amp;frida-tools<br/>\n确认测试机 cpu 架构，https://github.com/frida/frida/releases\xa0下载对应的frida-server–&gt;</p>\n<p>部署到手机并执行–&gt;</p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总3" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress7-1586442651.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总3"/></p>\n<p>tcp 转发，用于与 frida-server 通信,之后的每个端口对应每个注入的进程</p>\n<p>本地 DroidDrops 目录下执行</p>\n<p><code>frida -U com.zhiliaoapp.musically --no-pause -l hooks.js</code></p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总4" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress2-1586442651.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总4"/></p>\n<p>启动 App，charles 抓包恢复正常。</p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总5" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress0-1586442651.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总5"/></p>\n<p>（二）App双向验证APP 双向校验，即服务器要认证请求涞源是否真实客户端（来自真实证书），大概原理这样：</p>\n<p>app –&gt;服务端（证书）—- ok<br/>\napp（证书）&lt;–服务端—- ok</p>\n<p>解决两个技术点：</p>\n<p>APP 以为 Charles 是服务端（ Hook 绕过）<br/>\n服务端以为 Charles 是客户端 （逆向 APP ，获得证书导入到 charles ）</p>\n<p>非常见证书校验技术的通杀解决方案</p>\n<p>ssl_logger 的作用原理是 hook 底层 ssl_read 和 ssl_write 两个方法，完全不用配置代理，不用理解 APP 客户端和服务端的证书校验问题。</p>\n<p>大黑阔5alt发布过一个魔改版本，精品中的精品。<br/>\nhttps://github.com/5alt/ssl_logger</p>\n<p><img title="Android 7.0 Https抓包单双向验证解决方案汇总6" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress8-1586442651.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总6"/><br/>\n<img title="Android 7.0 Https抓包单双向验证解决方案汇总7" src="https://www.yuanrenxue.com/wp-content/uploads/2020/04/beepress3-1586442652.png" alt="Android 7.0 Https抓包单双向验证解决方案汇总7"/></p>\n<p><strong>PS：建了一个猿人学·爬虫技术交流群，加我微信，备注：猿人学，拉你进群</strong></p>\n<p><img class="" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398733.jpeg" width="252" height="252" alt="Android 7.0 Https抓包单双向验证解决方案汇总"/></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '这篇是跟我精进爬虫技术的小伙伴的实操总结文投稿，一篇标准的安卓7抓包指南。因为App对设备限制的原因，换了一台 Android 7 的测...');
(23, ['APP爬虫-双向认证抓包的两种方法'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/harbor.jpeg'], 1, '<p>APP抓包相对繁琐，越来越多的 APP 在 https 请求和响应时，为了防止中间人攻击（或中间人抓包），会做证书认证，让抓包工具抓不到请求。</p><p><img src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/Mutual-authentication.jpeg" alt="双向认证抓包"/></p><p>证书认证分单向认证和双向认证，双向认证是相较于单向认证而言的，单向认证就是只在 APP 侧做证书校验，单向认证有现成的解决方法，比如用各种 bypass ssl 校验的 hook 脚本既可让单向认证失效，例如：JustTrustMe 。如果 APP 的网络请求库有混淆，上述 bypass ssl 脚本无效，也有开源作者开发了自适配的 bypass 程序，可以 hook 混淆后的网络库。比如：JustMePlush 。</p><p>简单说了下单向认证如何解决，开始说双向认证如何解决。</p><p>双向认证除了要在 APP 侧做证书校验外， 对方服务端还要做证书校验。对方服务端是要检测证书的，不提交真正的证书给服务端，肯定会请求失败。</p><p>\xa0</p><p><strong>双向认证抓包有两种解决方法：</strong></p><p>一是：按照搞定证书的思路去想的话，就是要想办法拿到真正的证书。<br/>二是：Hook SSL 对数据解密数据的地方。</p><p>\xa0</p><p style="text-align: center;"><strong>方法一：</strong></p><p>因为 APP 能正常跟服务端通信，所以真正的证书肯定是在 APP 里面。所以就是要想办法从 APP 里抠出证书。抠证书有开源的 Frida Hook 脚本。如下地址是开源作者写的 Frida Hook 脚本<br/>https://gist.github.com/ceres- c/cb3b69e53713d5ad9cf6aac9b8e895d2gfgg<br/>可以把证书从内存里读出来保存到本地，并且证书密码也能读出来，非常的方便。</p><p><strong>该脚本的原理是：</strong><br/>因为 APP 在向服务端发请求时， APP 肯定会操作证书，所以如果能找到 APP 操作证书的代码地方， Hook 这部分代码，对参数做些输出打印，证书和证书密码就都有了。</p><p>大部分情况下，我们不用非常熟悉安卓原理，比如安卓在代码层面是如何操作证书的（当然熟悉更好）。因为资讯发达，一般灵活借助搜索引擎，灵活查阅资料，可以大体知道这些，就可以尝试去写 Hook 脚本去尝试看看。</p><p>查阅资料可以知道，安卓操作证书通常是 java.security.KeyStore 这个类，然后再了解下这个类的用法，参数形式。就可以尝试去 Hook 了。上述脚本就是 Hook java.security.KeyStore 这个类的 load 方法，load 方法的形参就是我们需要的证书和密码。</p><p>抠出的证书和密码，配置进 fiddler 或 charles 里面，就可以抓到双向认证的包。<br/>PS： 还要注意证书的格式，抠出的证书可能是 jks 或 bks 格式的，fiddler 可能需要 p12 格式的， 所以要找工具先转换一下格式。</p><p>\xa0</p><p style="text-align: center;"><strong>方法二：</strong></p><p>如果只是想抓包，还有另一种方法，不需要抠证书的方法。虽然 https 在传输过程中是加密的，但在终端显示的时候，必然会解密，不然 APP 上都没法显示了。所以如果能知道安卓解密 SSL 加解密是哪个类， Hook 这个类， 类里相关方法的输入输出肯定就是传输的明文数据。</p><p>所以可以查阅资料，看看相关类的用法，就可以尝试去 Hook 打印输出看看情况。也有开源作者开源了该 Hook 脚本， 比如 5alt 老板在google开源的脚本基础上做了修改了的 ssl_logger 。<br/>https://github.com/5alt/ssl_logger</p><p>能够 Hook SSL 加解密的地方，它会把传输的数据保存为 pcap 格式。再使用 wireshark 打开该 pcap文件， 在 wireshark 上就可以看到明文的数据了。</p><p>如果要模拟向服务器发送请求的话，还是只能使用第一种方法，因为客服端必须要提交正确的证书，服务端才会正确响应。必须得抠出证书，模拟请求时必须带上证书，才能请求到数据。安卓上的证书好多是 jks/bks格式的， 如果使用 Python requests 库的话， 不支持这个格式， 所以要想办法把证书转成 cert 格式的。</p><p>上面两种方法都是使用 Frida 进行 Hook ，所以要有 Root 过的手机和明白Frida 怎么使用就能搞定。</p><p>对于爬虫来说，搞定抓包和请求参数加密的问题，大部分 Hook ，都可以通过 Hook 安卓系统 API 来找到 APP 代码位置，或直接搞定。其实很少人能很熟悉安卓系统的各种原理，大部分时候能灵活通过各种关键字能查到相关原理的讲解文献，文献里讲的 API 灵活点拿去 Hook 康康线索，就能搞定很多拉。</p><p>其实使用双向认证的 APP 还是少数， 对服务器性能多少有影响。</p><p>\xa0</p><p><strong><span style="color: #00ff00;">PS ：建了一个爬虫技术和爬虫技术做副业交流群， 可以扫我私人微信（dismissmewp）加入，备注：猿人学 。</span></strong></p><p><img class="" src="https://www.yuanrenxue.com/wp-content/uploads/2019/11/personal-wechat.jpg" alt="personal wechat" width="246" height="246"/></p><p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, 'APP抓包相对繁琐，越来越多的 APP 在 https 请求和响应时，为了防止中间人攻击（或中间人抓包），会做证书认证，让抓包工具抓不到请...');
(24, ['Protobuf协议逆向解析-APP爬虫'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/prometheus.png'], 1, '<p>在做APP抓取时，会发现有的APP Response回来的数据有“加密”。不知道返回的内容是什么。</p>\n<p>本文偏长，理论基础偏多。</p>\n<p>如下：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398723.jpg" alt="APP爬虫之-Protobuf协议逆向解析"/><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress2-1583398724.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>如上，内容不是明文的，没办法解析数据。</p>\n<p>APP常见的对数据加密有三种情况：</p>\n<p>第一种是，用诸如AES这类加密算法对数据加密，然后在APP里用key进行解密，这类的数据解密的难度不是很大，弄清楚是用的什么加密算法就能反解。</p>\n<p>第二种是，用“私有”协议把数据序列化，只有了解该协议的细节才有可能把数据反序列化出来。这个的难度较大，没有功底，头发撸白都不一定撸出来。游戏和大厂APP盛行搞一个自己的私有协议来交换数据。</p>\n<p>第三种是，用第三方厂商的协议来数据序列化，自己搞不出来私有协议的就选用第三方厂商的。比如用 Google 的 Protobuf ，来做数据序列化，也就是数据“加密”。</p>\n<p><strong>今天聊的就是第三种，Protobuf 的数据反解析。</strong></p>\n<p>先来看一个 Protobuf ，做数据序列化的直观例子。</p>\n<p>比如一个 APP 的 Response 原先是以 json 格式返回的：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398725.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>这样很容易被解析，用Protobuf把上面数据序列化再传输就变成类似这样：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398725-1.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>这张图片只是样例这样就没法直接解析数据，如果了解 Protobuf 协议的话就能加快反解速度。</p>\n<p>所以还得从头来聊 Protobuf 。</p>\n<p>\xa0</p>\n<p>Protobuf 是 Google 开发的一套数据存储传输协议，跟 xml 和 json 一样的，都是用来储存和传输数据的。\xa0因为 Protobuf 能够把数据压缩得很小，所以传输数据就比 xml 和 json 快几倍，Protobuf 解析数据的速度也比它两快，所以在数据网络传输上，用 Protobuf 而不用 json 就有点受欢迎了。</p>\n<p>不过 Protobuf 储存、压缩、传输效率比 json 好，付出的代价就是用法麻烦，不像 json.loads() json.dumps()\xa0一下就搞定了这么简单。Protobuf 有一套自己的语法。不了解 Protobuf 协议语法和用法的话也无法反解数据。</p>\n<p><strong>先了解下 Protobuf 序列化和反序列化的整个流程：</strong></p>\n<p><strong>1.1.先定义一个 Protobuf\xa0语法文件（\xa0.proto 文件）</strong></p>\n<p>该语法文件用来说明要传输哪些字段、字段的数据类型、数据间的嵌套关系这些。比如一个APP要返回的数据有电话号码，姓名，年龄这三个字段，你就需要把这三个字段定义在 .proto 文件里，并且指明他们的数据类型，比如姓名和电话是字符串， 年龄是整型。</p>\n<p><strong>1.2.使用 Protobuf 提供的工具编译该语法文件。</strong></p>\n<p>用工具编译 .proto 文件的目的是，把 .proto 文件编译成代码，工具会根据该 .proto 文件自动生产代码。\xa0这个代码就是用来做数据序列化和反序列化的。</p>\n<p><strong>1.3.服务端用第2步中的代码，把“明文”数据序列化，变成“密文”后，返回给APP。</strong></p>\n<p><strong>1.4. APP 客户端用第2步中的代码，把“密文”数据反序列化，就“解密”成明文拉。</strong></p>\n<p>理论说多了很迷糊，再整个完整的直观例子：</p>\n<p>2.1.先配置 Protobuf 环境https://github.com/protocolbuffers/protobuf/releases/</p>\n<p>在 Google 官方 github 地址下载 Protobuf \xa0。</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress8-1583398725.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>下载一个 Protobuf 编译器和一个调用编译器的接口程序，我们这里用Python版的。如上图，箭头所示，解压 protoc.win64.zip 里有个 protoc 命令就是编译器。PS：注意要给 protoc 配置上环境变量，不然没法全局调用该命令。</p>\n<p>解压 protobuf-python-3.11.4.zip 这是Python模块，cd到python目录里运行 Python setup.py build 和 Python setup.py install 安装Python模块。Python编辑器里运行 import google.protobuf 可以检测是否安装成功。</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress4-1583398726.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>\xa0</p>\n<p>example目录里有官方写好的Python示例程序 和\xa0示例 .proto文件。</p>\n<p>2.2.写一个 .proto\xa0语法文件语法文件怎么写，要根据具体的传输数据来定制，</p>\n<p>比如按照 example 里的示例，如果要传输的数据是如下格式：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress6-1583398730.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>那么定义的 .proto 语法文件就如下：</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress6-1583398731.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>这样就定义好了一个 .proto 语法文件，语法文件如何定义要根据传输数据的不同而变。更全的 protobuf 语法 可以看这个，有网友翻译成了中文版的。https://colobu.com/2017/03/16/Protobuf3-language-guide/</p>\n<p>2.3.使用第一步中下载的 protoc 编译器来编译 .proto 文件</p>\n<p>protoc –python_out=. addressbook.proto</p>\n<p>上述表示把 addressbook.proto 文件编译成Python版的。如果文件语法错误，在编译的时候会有提示。编译完后，会多出一个.py文件</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress1-1583398731.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>\xa0</p>\n<p>我们就可以调用这个 .py 来序列化上面的数据。2.4.开始序列化数据</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress5-1583398732.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>\xa0</p>\n<p>print里输出的就是序列化（“加密”）后的数据。2.5.对序列化后的数据进行反序列化（“解密”）</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398732.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>\xa0</p>\n<p>反序列化就把数据又还原啦。</p>\n<p>上述过程就是一个完整的正向数据 protobuf 序列化过程。我们可以看出来，主要是定义一个 .proto 文件，然后把它编译生成代码。\xa0后面就主要用这个代码来做序列化和反序列化工作。</p>\n<p>\xa0</p>\n<p>正向过程比较轻松，因为对方即有 .proto 文件，也有序列化代码，也知道要传输的数据样式。但是逆向这个过程，APP里是没有 .proto文件的，APP里是有反序列化的代码，但是看得也头晕。那该怎么办呢？</p>\n<p>借助工具，我们使用上面下载的protoc编译工具，这个工具提供反解析参数</p>\n<p>protoc –decode_raw &lt; people.bin</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress10-1583398732.png" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>如上，使用 –decode_raw 参数就能把序列化后的数据，反序列化（解密）出来。上面只是把数据还原了，那如果我们要完全把 .proto 文件也还原出来该怎么办呢？</p>\n<p>如果 APP 发送 request 的数据要先序列化后再发送给服务端的话，那爬虫要做的事情就不只反序列化，还要能序列化。做序列化是一个正向的过程，按照上面流程，必须先要有 .proto 文件才行。</p>\n<p>所以继续还原 .proto 文件，还原 .proto 是个体力活和细致活。就是参照反解析出来的数据，还原出 .proto 文件。</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress9-1583398733.jpg" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n<p>上面这张图是关键，看懂了就能还原出来。上图左边是反解析出来的数据，中中间是参照左边写出来的 .proto 文件，右边是人家原本的 .proto 文件。左边和中间图对比可以看出，就是根据左边的字段，挨个把字段重新定义出来就OK啦。</p>\n<p>遇到\xa0“{” 就定义一个message。中间和右边图对比可以看出，变量的名字是无关紧要的，数据类型还原正确就行。变量赋值的那些1，2，3是标识号，message里同一层级的标识号不能重复，一般是按照变量顺序从1开始递增。标识号的数字是个关键，数字写错了反解析出来的数据会不对。这样就把 .proto 文件还原出来了，然后按照正向流程又去编译，就可以使用它去序列化（“加密”）和反序列化（“解密”）APP数据了。</p>\n<p>\xa0</p>\n<p><strong>APP逆向抓取相关阅读</strong></p>\n<p><a href="https://www.yuanrenxue.com/app-crawl/app-crawl-1.html" target="_blank" rel="noopener">爬虫之-某生鲜APP加密参数逆向分析</a></p>\n<p><a href="https://www.yuanrenxue.com/crawler/frida-call-so-directly.html" target="_blank" rel="noopener">搞定某APP的TCP抓包，并实现Hook抓取</a></p>\n<p><a href="https://www.yuanrenxue.com/crawler/crawl-app-frida-rpc.html" target="_blank" rel="noopener">不还原token算法抓取APP最简单的Hook方法</a></p>\n<p>\xa0</p>\n<p><strong>PS: 再广而告之一声</strong></p>\n<p>我有在系统性的教爬虫技术APP逆向抓取技术JS高阶逆向技术群控抓取技术</p>\n<p>利用爬虫技术年挣10万被动收入的思维和实践方法如果你想爬虫技术进阶，或找一份不错的爬虫工作，我想是能够有帮助的。感兴趣可以加我私人微信，备注：学习。PS，费用不便宜，非诚勿扰。</p>\n<p><img title="APP爬虫之-Protobuf协议逆向解析" src="https://www.yuanrenxue.com/wp-content/uploads/2020/03/beepress0-1583398733.jpeg" alt="APP爬虫之-Protobuf协议逆向解析"/></p>\n <p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '在做APP抓取时，会发现有的APP Response回来的数据有“加密”。不知道返回的内容是什么。本文偏长，理论基础偏多。如下：如上，内...');
(25, ['爬虫之-某生鲜APP加密参数逆向分析'], 1, 2, ['https://www.lujianxin.com//media/blog/cover/cloud-cover.jpg'], 1, '<p/><p/><p><em>我的公众号：<strong>猿人学 Python</strong> 上会分享更多心得体会，敬请关注。</em></p><p><em>***版权申明:若没有特殊说明，文章皆是猿人学 yuanrenxue.com 原创，没有猿人学授权，请勿以任何形式转载。***</em></p> <p class="tags"/> ', 'www.ccmsy.com', 0, 0, 99, 99, '2020-11-20 19:43:47', '2020-11-20 19:43:47.320327', 1, '本文是跟我学习爬虫的小伙伴：彭良怀的投稿，稿费是500。本文写得非常好，完全可以当着APP逆向抓取的教程来学。从逆向思路的分析，...');

